{
    "summary": {
        "overview": "The Playable Piano web application allows users to interact with a virtual piano. Users can click on piano keys or press corresponding keyboard keys to play notes. The application includes features for adjusting volume and toggling the visibility of key labels.",
        "predefined_options": "The web application initializes with a default volume level set to 0.5, and piano key labels are displayed by default upon launch. It features a virtual piano with both black and white keys, each mapped to specific keyboard characters. The black keys correspond to the uppercase letters W, E, T, Y, U, O, and P, while the white keys correspond to A, S, D, F, G, H, J, K, L, and ;. Each key element in the DOM is assigned a unique data-test-id attribute in the format data-test-id=\"piano-key-'x'\", where 'x' is the lowercase version of the corresponding keyboard character (e.g., the key for W uses data-test-id=\"piano-key-'w'\").",
        "external_resources": "The corresponding audio files for each piano note are stored in the tunes directory, with filenames matching the lowercase key characters followed by .wav, such as tunes/a.wav, tunes/;.wav, tunes/d.wav, tunes/e.wav, and so on, covering all relevant keys including w, e, t, y, u, o, p, a, s, d, f, g, h, j, k, l, and ;.",
        "external_js_libraries": "No external JavaScript libraries are used in this application."
    },
    "finegrained_rewith_test": {
        "1": {
            "requirement": {
                "description": "When the user clicks any visible piano key on the webpage, identified by its data-testid (e.g., 'piano-key-a' for the white key 'a' or 'piano-key-w' for the black key 'w'), the system must play the corresponding sound file from the 'tunes' directory (e.g., 'tunes/a.wav' for key 'a'). The clicked key must receive the 'active' class to visually highlight it, and the highlight must be removed after 150ms by removing the 'active' class."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Play piano sound and visually highlight the key when clicked\n  The system must play the corresponding piano sound and visually highlight the key when the user clicks on a piano key. The highlight should disappear after 150ms.\n\n\nScenario: [Normal] User clicks on a white piano key\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on the white piano key with data-testid \"piano-key-a\"\n    Then the system must play the sound \n    And the key with data-testid \"piano-key-a\" must have the \"active\" class added\n    And the \"active\" class must be removed from the key with data-testid \"piano-key-a\" after 150ms"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the webpage is loaded and the piano keys are visible')\ndef step_given_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    \n    # Wait for the piano keys to be visible\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    time.sleep(1)  # Allow time for the page to fully load\n\n@when('the user clicks on the white piano key with data-testid \"piano-key-a\"')\ndef step_when_user_clicks_piano_key(context):\n    # Locate the piano key and click it\n    piano_key = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    piano_key.click()\n\n@then('the system must play the sound')\ndef step_then_system_plays_sound(context):\n    # Verify that the audio element's source is updated to the correct sound file\n    pass\n\n@then('the key with data-testid \"piano-key-a\" must have the \"active\" class added')\ndef step_then_key_has_active_class(context):\n    # Verify that the key has the \"active\" class\n    piano_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    class_list = piano_key.get_attribute(\"class\").split()\n    assert \"active\" in class_list, \"The 'active' class was not added to the key\"\n\n@then('the \"active\" class must be removed from the key with data-testid \"piano-key-a\" after 150ms')\ndef step_then_active_class_removed(context):\n    # Wait for 150ms and verify that the \"active\" class is removed\n    time.sleep(0.15)\n    piano_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    class_list = piano_key.get_attribute(\"class\").split()\n    assert \"active\" not in class_list, \"The 'active' class was not removed from the key\"\n\n# Teardown to close the browser after the test\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Play piano sound and visually highlight the key when clicked\n  The system must play the corresponding piano sound and visually highlight the key when the user clicks on a piano key. The highlight should disappear after 150ms.\n\n\n  Scenario: [Normal] User clicks on a black piano key\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on the black piano key with data-testid \"piano-key-w\"\n    Then the system must play the sound\n    And the key with data-testid \"piano-key-w\" must have the \"active\" class added\n    And the \"active\" class must be removed from the key with data-testid \"piano-key-w\" after 150ms\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_expanded(element):\n    aria = element.get_attribute(\"aria-expanded\")\n    if aria is not None:\n        return aria == \"true\"\n\n    class_list = element.get_attribute(\"class\").split()\n    if any(cls in class_list for cls in [\"expanded\", \"open\", \"show\"]):\n        return True\n\n    data_expanded = element.get_attribute(\"data-expanded\")\n    if data_expanded is not None:\n        return data_expanded == \"true\"\n\n    return element.is_displayed()\n\ndef is_collapsed(element):\n    aria = element.get_attribute(\"aria-expanded\")\n    if aria is not None and aria.lower() == \"false\":\n        return True\n\n    class_attr = element.get_attribute(\"class\") or \"\"\n    class_list = class_attr.split()\n    if \"collapsed\" in class_list:\n        return True\n\n    data_expanded = element.get_attribute(\"data-expanded\")\n    if data_expanded is not None and data_expanded.lower() == \"false\":\n        return True\n\n    style = element.get_attribute(\"style\") or \"\"\n    if \"display: none\" in style or \"visibility: hidden\" in style or \"height: 0\" in style:\n        return True\n\n    return not element.is_displayed()\n\n@given('the webpage is loaded and the piano keys are visible')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \".piano-keys .key\"))\n    )\n    time.sleep(1)\n\n@when('the user clicks on the black piano key with data-testid \"piano-key-w\"')\ndef step_when_user_clicks_black_key(context):\n    key = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='piano-key-w']\"))\n    )\n    key.click()\n    # time.sleep(1)\n\n@then('the system must play the sound')\ndef step_then_system_plays_sound(context):\n    # This step would typically require mocking or intercepting the audio play event\n    # Since we can't directly verify audio playback with Selenium, we assume the click triggers the audio\n    pass\n\n@then('the key with data-testid \"piano-key-w\" must have the \"active\" class added')\ndef step_then_key_has_active_class(context):\n    key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    assert \"active\" in key.get_attribute(\"class\").split(), \"Key does not have 'active' class\"\n\n@then('the \"active\" class must be removed from the key with data-testid \"piano-key-w\" after 150ms')\ndef step_then_active_class_removed(context):\n    time.sleep(0.15)  # Wait for 150ms\n    key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    assert \"active\" not in key.get_attribute(\"class\").split(), \"Key still has 'active' class\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Play piano sound and visually highlight the key when clicked\n  The system must play the corresponding piano sound and visually highlight the key when the user clicks on a piano key. The highlight should disappear after 150ms.\n\n\nScenario: [Edge] User clicks multiple piano keys in quick succession\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on the white piano key with data-testid \"piano-key-a\"\n    And immediately clicks on the black piano key with data-testid \"piano-key-w\"\n    Then the system must play the sound\n    And the system must play the sound\n    And the key with data-testid \"piano-key-a\" must have the \"active\" class added\n    And the key with data-testid \"piano-key-w\" must have the \"active\" class added\n    And the \"active\" class must be removed from the key with data-testid \"piano-key-a\" after 150ms\n    And the \"active\" class must be removed from the key with data-testid \"piano-key-w\" after 150ms"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the webpage is loaded and the piano keys are visible\")\ndef step_given_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    \n    # Wait for the piano keys to be visible\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_all_elements_located((By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\"))\n    )\n    time.sleep(1)  # Ensure stability after loading\n\n@when('the user clicks on the white piano key with data-testid \"piano-key-a\"')\ndef step_when_click_white_key_a(context):\n    # Locate the white piano key with data-testid \"piano-key-a\" and click it\n    key_a = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    key_a.click()\n\n@when('immediately clicks on the black piano key with data-testid \"piano-key-w\"')\ndef step_when_click_black_key_w(context):\n    # Locate the black piano key with data-testid \"piano-key-w\" and click it\n    key_w = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='piano-key-w']\"))\n    )\n    key_w.click()\n\n@then(\"the system must play the sound\")\ndef step_then_play_sound_file(context):\n    # Verify that the audio element is updated with the correct sound file\n    pass\n\n@then('the key with data-testid \"piano-key-a\" must have the \"active\" class added')\ndef step_then_key_a_active_class_added(context):\n    # Verify that the key with data-testid \"piano-key-a\" has the \"active\" class\n    key_a = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    class_list = key_a.get_attribute(\"class\").split()\n    assert \"active\" in class_list, f\"'active' class not found in key 'piano-key-a'. Current classes: {class_list}\"\n\n@then('the \"active\" class must be removed from the key with data-testid \"piano-key-a\" after 150ms')\ndef step_then_key_a_active_class_removed(context):\n    time.sleep(0.15)  # Wait for 150ms\n    key_a = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    class_list = key_a.get_attribute(\"class\").split()\n    assert \"active\" not in class_list, f\"'active' class still present in key 'piano-key-a'. Current classes: {class_list}\"\n\n@then('the key with data-testid \"piano-key-w\" must have the \"active\" class added')\ndef step_then_key_w_active_class_added(context):\n    # Verify that the key with data-testid \"piano-key-w\" has the \"active\" class\n    key_w = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    class_list = key_w.get_attribute(\"class\").split()\n    assert \"active\" in class_list, f\"'active' class not found in key 'piano-key-w'. Current classes: {class_list}\"\n\n@then('the \"active\" class must be removed from the key with data-testid \"piano-key-w\" after 150ms')\ndef step_then_key_w_active_class_removed(context):\n    time.sleep(0.15)  # Wait for 150ms\n    key_w = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    class_list = key_w.get_attribute(\"class\").split()\n    assert \"active\" not in class_list, f\"'active' class still present in key 'piano-key-w'. Current classes: {class_list}\"\n\n# Teardown step to close the browser after the test\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "3": {
            "requirement": {
                "description": "The system must allow the user to adjust the audio volume using a slider (data-testid='volume-slider') with a range from 0 (mute) to 1 (maximum volume). Interacting with the slider updates the audio volume accordingly, with 0 muting the audio, 1 playing at full volume. The volume change must be reflected immediately upon slider adjustment."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Adjusting the volume slider to control audio playback volume\n  The user should be able to adjust the volume slider to control the audio playback volume, with values ranging from 0 (mute) to 1 (maximum volume).\n\n\n  Scenario: [Normal] Adjusting the volume slider updates the audio playback volume\n    Given the piano webpage is loaded\n    And the volume slider with data-testid \"volume-slider\" is visible and set to 0.5\n    When the user moves the volume slider to 0.8\n    Then the audio playback volume should be updated to 0.8\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the piano webpage is loaded\")\ndef step_given_piano_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow the page to load completely\n\n@given('the volume slider with data-testid \"volume-slider\" is visible and set to 0.5')\ndef step_given_volume_slider_visible_and_set(context):\n    # Wait for the volume slider to be visible\n    volume_slider = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    assert volume_slider.is_displayed(), \"Volume slider is not visible\"\n    \n    # Verify the initial value of the slider\n    initial_value = volume_slider.get_attribute(\"value\")\n    assert initial_value == \"0.5\", f\"Expected slider value to be 0.5, but got {initial_value}\"\n\n@when(\"the user moves the volume slider to 0.8\")\ndef step_when_user_moves_volume_slider(context):\n    # Locate the volume slider and update its value\n    volume_slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    context.driver.execute_script(\"arguments[0].value = 0.8; arguments[0].dispatchEvent(new Event('input'));\", volume_slider)\n    time.sleep(1)  # Allow the slider change to take effect\n\n@then(\"the audio playback volume should be updated to 0.8\")\ndef step_then_audio_volume_updated(context):\n    # Verify the updated volume value\n    volume_slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    updated_value = volume_slider.get_attribute(\"value\")\n    assert updated_value == \"0.8\", f\"Expected slider value to be 0.8, but got {updated_value}\"\n\n    # Cleanup: Close the browser driver\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Adjusting the volume slider to control audio playback volume\n  The user should be able to adjust the volume slider to control the audio playback volume, with values ranging from 0 (mute) to 1 (maximum volume).\n\n\n  Scenario: [Edge] Setting the volume slider to the minimum value (mute)\n    Given the piano webpage is loaded\n    And the volume slider with data-testid \"volume-slider\" is visible and set to 0.5\n    When the user moves the volume slider to 0\n    Then the audio playback volume should be updated to 0\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the piano webpage is loaded\")\ndef step_given_piano_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    time.sleep(1)  # Allow the page to load completely\n\n@given('the volume slider with data-testid \"volume-slider\" is visible and set to 0.5')\ndef step_given_volume_slider_visible_and_set(context):\n    # Wait for the volume slider to be visible\n    slider = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    # Assert the slider is visible\n    assert slider.is_displayed(), \"Volume slider is not visible\"\n    # Assert the slider's initial value is 0.5\n    assert slider.get_attribute(\"value\") == \"0.5\", f\"Expected slider value to be 0.5, but got {slider.get_attribute('value')}\"\n\n@when(\"the user moves the volume slider to 0\")\ndef step_when_user_moves_volume_slider(context):\n    # Locate the volume slider\n    slider = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    # Set the slider value to 0 using JavaScript\n    context.driver.execute_script(\"arguments[0].value = 0;\", slider)\n    # Trigger the input event to simulate user interaction\n    context.driver.execute_script(\"arguments[0].dispatchEvent(new Event('input'));\", slider)\n    time.sleep(1)  # Allow time for the event to propagate\n\n@then(\"the audio playback volume should be updated to 0\")\ndef step_then_audio_playback_volume_updated(context):\n    # Validate the audio volume is updated to 0\n    slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    assert slider.get_attribute(\"value\") == \"0\", f\"Expected slider value to be 0, but got {slider.get_attribute('value')}\"\n    # Optionally, check the audio volume directly if accessible\n    audio_volume = context.driver.execute_script(\"return audio.volume;\")\n    assert audio_volume == 0, f\"Expected audio volume to be 0, but got {audio_volume}\"\n\n# Teardown after the test\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Adjusting the volume slider to control audio playback volume\n  The user should be able to adjust the volume slider to control the audio playback volume, with values ranging from 0 (mute) to 1 (maximum volume).\n\n\n  Scenario: [Edge] Setting the volume slider to the maximum value\n    Given the piano webpage is loaded\n    And the volume slider with data-testid \"volume-slider\" is visible and set to 0.5\n    When the user moves the volume slider to 1\n    Then the audio playback volume should be updated to 1\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the piano webpage is loaded')\ndef step_given_piano_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the volume slider with data-testid \"volume-slider\" is visible and set to 0.5')\ndef step_given_volume_slider_visible(context):\n    volume_slider = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    assert volume_slider.get_attribute(\"value\") == \"0.5\", \"Volume slider is not set to 0.5\"\n    time.sleep(1)\n\n@when('the user moves the volume slider to 1')\ndef step_when_user_moves_volume_slider(context):\n    slider = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    # Set the slider value to 0 using JavaScript\n    context.driver.execute_script(\"arguments[0].value = 1;\", slider)\n    # Trigger the input event to simulate user interaction\n    context.driver.execute_script(\"arguments[0].dispatchEvent(new Event('input'));\", slider)\n    time.sleep(1)  # Allow time for the event to propagate\n\n@then('the audio playback volume should be updated to 1')\ndef step_then_audio_playback_volume_updated(context):\n    # Validate the audio volume is updated to 0\n    slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    assert slider.get_attribute(\n        \"value\") == \"1\", f\"Expected slider value to be 1, but got {slider.get_attribute('value')}\"\n    # Optionally, check the audio volume directly if accessible\n    audio_volume = context.driver.execute_script(\"return audio.volume;\")\n    assert audio_volume == 1, f\"Expected audio volume to be 1, but got {audio_volume}\"\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Adjusting the volume slider to control audio playback volume\n  The user should be able to adjust the volume slider to control the audio playback volume, with values ranging from 0 (mute) to 1 (maximum volume).\n\n\n  Scenario: [Error] Providing an invalid value outside the slider range\n    Given the piano webpage is loaded\n    And the volume slider with data-testid \"volume-slider\" is visible and set to 0.5\n    When the user attempts to set the volume slider to -0.5\n    Then the audio playback volume should remain unchanged at 0\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the piano webpage is loaded')\ndef step_given_piano_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the volume slider with data-testid \"volume-slider\" is visible and set to 0.5')\ndef step_given_volume_slider_visible(context):\n    volume_slider = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    assert volume_slider.is_displayed(), \"Volume slider is not visible\"\n    assert volume_slider.get_attribute(\"value\") == \"0.5\", \"Volume slider is not set to 0.5\"\n    time.sleep(1)\n\n@when('the user attempts to set the volume slider to -0.5')\ndef step_when_user_sets_volume_slider(context):\n    volume_slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    context.driver.execute_script(\"arguments[0].value = -0.5;\", volume_slider)\n    time.sleep(1)\n\n@then('the audio playback volume should remain unchanged at 0')\ndef step_then_audio_volume_unchanged(context):\n    volume_slider = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='volume-slider']\")\n    assert volume_slider.get_attribute(\"value\") == \"0\", \"Audio playback volume has changed\"\n    time.sleep(1)\n    context.driver.quit()"
                }
            ]
        },
        "4": {
            "requirement": {
                "description": "When the user interacts with the 'Show Keys' checkbox (identified by `data-testid='show-keys-checkbox'`), the system must toggle the visibility of key labels on the piano keys (identified by `data-testid` starting with 'piano-key') by adding or removing the 'hide' class. Initially, the labels are visible. When the checkbox is checked, clicking it should hide the labels by adding the 'hide' class to all piano keys. When unchecked, clicking it should restore the labels by removing the 'hide' class. The system must handle rapid toggling, ensuring the final state of the labels is consistent and correct."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Toggle visibility of piano key labels\n  The system must toggle the visibility of the key labels on the piano keys when the user clicks the 'Show Keys' checkbox.\n\n\n  Scenario: [Normal] Toggle key labels visibility on checkbox click\n    Given the Playable Piano page is loaded\n    And the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is checked\n    When the user clicks the 'Show Keys' checkbox\n    Then each piano key with data-testid starting with 'piano-key' should have the 'hide' class added\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n# Background setup\n@given(\"the Playable Piano page is loaded\")\ndef step_given_playable_piano_page_loaded(context):\n    context.driver = webdriver.Chrome()  # Initialize the WebDriver\n    context.driver.get(f\"file://index.html\")  # Load the test page\n    context.driver.maximize_window()\n    time.sleep(1)  # Allow the page to load completely\n\n@given(\"the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is checked\")\ndef step_given_show_keys_checkbox_checked(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    assert checkbox.is_selected(), \"Expected 'Show Keys' checkbox to be checked\"\n    time.sleep(1)\n\n# Scenario steps\n@when(\"the user clicks the 'Show Keys' checkbox\")\ndef step_when_user_clicks_show_keys_checkbox(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    checkbox.click()\n    time.sleep(1)  # Allow time for the UI to update\n\n@then(\"each piano key with data-testid starting with 'piano-key' should have the 'hide' class added\")\ndef step_then_piano_keys_hide_class_added(context):\n    piano_keys = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_all_elements_located((By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\"))\n    )\n    for key in piano_keys:\n        class_list = key.get_attribute(\"class\").split()\n        assert \"hide\" in class_list, f\"Expected 'hide' class in piano key: {key.get_attribute('data-testid')}\"\n    time.sleep(1)\n\n# Teardown\ndef after_scenario(context, scenario):\n    context.driver.quit()  # Ensure the browser is closed after the test"
                },
                {
                    "test_case": [
                        "Feature: Toggle visibility of piano key labels\n  The system must toggle the visibility of the key labels on the piano keys when the user clicks the 'Show Keys' checkbox.\n\n\n  Scenario: [Normal] Restore key labels visibility on checkbox click\n    Given the Playable Piano page is loaded\n    And the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is unchecked\n    When the user clicks the 'Show Keys' checkbox\n    Then each piano key with data-testid starting with 'piano-key' should have the 'hide' class removed\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the Playable Piano page is loaded\")\ndef step_given_playable_piano_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given(\"the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is unchecked\")\ndef step_given_show_keys_checkbox_unchecked(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    if checkbox.is_selected():\n        checkbox.click()\n        time.sleep(1)\n\n@when(\"the user clicks the 'Show Keys' checkbox\")\ndef step_when_user_clicks_show_keys_checkbox(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    checkbox.click()\n    time.sleep(1)\n\n@then(\"each piano key with data-testid starting with 'piano-key' should have the 'hide' class removed\")\ndef step_then_piano_keys_should_have_hide_class_removed(context):\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    for key in piano_keys:\n        class_list = key.get_attribute(\"class\").split()\n        assert \"hide\" not in class_list, f\"Expected 'hide' class to be removed from key with data-testid '{key.get_attribute('data-testid')}'\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Toggle visibility of piano key labels\n  The system must toggle the visibility of the key labels on the piano keys when the user clicks the 'Show Keys' checkbox.\n\n\n  Scenario: [Edge] Rapid toggling of the 'Show Keys' checkbox\n    Given the Playable Piano page is loaded\n    And the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is checked\n    When the user rapidly clicks the 'Show Keys' checkbox five times\n    Then the final state of each piano key with data-testid starting with 'piano-key' should have the 'hide' class\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_collapsed(element):\n    aria = element.get_attribute(\"aria-expanded\")\n    if aria is not None and aria.lower() == \"false\":\n        return True\n\n    class_attr = element.get_attribute(\"class\") or \"\"\n    class_list = class_attr.split()\n    if \"collapsed\" in class_list:\n        return True\n\n    data_expanded = element.get_attribute(\"data-expanded\")\n    if data_expanded is not None and data_expanded.lower() == \"false\":\n        return True\n\n    style = element.get_attribute(\"style\") or \"\"\n    if \"display: none\" in style or \"visibility: hidden\" in style or \"height: 0\" in style:\n        return True\n\n    return not element.is_displayed()\n\n@given(\"the Playable Piano page is loaded\")\ndef step_given_playable_piano_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='volume-slider']\"))\n    )\n    time.sleep(1)\n\n@given(\"the 'Show Keys' checkbox with data-testid 'show-keys-checkbox' is checked\")\ndef step_given_show_keys_checkbox_checked(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    assert checkbox.is_selected(), \"Expected 'Show Keys' checkbox to be checked\"\n    time.sleep(1)\n\n@when(\"the user rapidly clicks the 'Show Keys' checkbox five times\")\ndef step_when_user_rapidly_clicks_checkbox(context):\n    checkbox = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='show-keys-checkbox']\"))\n    )\n    for _ in range(5):\n        checkbox.click()\n        time.sleep(0.5)  # Short delay to simulate rapid clicking\n\n@then(\"the final state of each piano key with data-testid starting with 'piano-key' should have the 'hide' class\")\ndef step_then_final_state_of_piano_keys(context):\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    for key in piano_keys:\n        class_list = key.get_attribute(\"class\").split()\n        assert \"hide\" in class_list, f\"Expected 'hide' class to be in the key: {key.get_attribute('data-testid')}\"\n    time.sleep(1)\n\n# Cleanup after tests\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                }
            ]
        },
        "5": {
            "requirement": {
                "description": "The system must display all piano keys (white and black) in the UI, each labeled with its corresponding keyboard key. The piano keys must include both white and black keys, with the following labels: 'a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';'. Each key must be represented as an HTML <li> element with the class 'key' and either 'white' or 'black', depending on the type of key. The keys must also include a 'data-key' attribute corresponding to their label and a 'data-testid' attribute in the format 'piano-key-{label}' (e.g., 'piano-key-a'). The labels must be displayed as <span> elements nested within the <li> elements. The keys must be contained within a <ul> element with the class 'piano-keys'. The system must ensure that all keys are visible by default when the webpage is loaded, and their labels must be displayed unless the 'Show Keys' checkbox is unchecked. The checkbox must be represented as an HTML <input> element with the type 'checkbox', a 'data-testid' attribute of 'show-keys-checkbox', and must toggle the visibility of the labels when clicked."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Display of Piano Keys\n  The system must display all piano keys (white and black) in the UI, each labeled with its corresponding keyboard key.\n\n\n  Scenario: [Normal] Display all piano keys with labels\n    Given the Playable Piano webpage is loaded\n    Then all piano keys should be visible\n    And each piano key should display its corresponding keyboard key label\n    And the labels should be 'a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';'\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the Playable Piano webpage is loaded\")\ndef step_given_playable_piano_webpage_loaded(context):\n    # Initialize the Selenium WebDriver\n    context.driver = webdriver.Chrome()\n    # Load the test page dynamically\n    context.driver.get(f\"file://index.html\")\n    # Maximize the browser window for better visibility\n    context.driver.maximize_window()\n    time.sleep(1)  # Allow the page to load completely\n\n@then(\"all piano keys should be visible\")\ndef step_then_all_piano_keys_visible(context):\n    # Wait for all piano keys to be visible\n    piano_keys = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_all_elements_located((By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\"))\n    )\n    # Assert that all keys are visible\n    for key in piano_keys:\n        assert key.is_displayed(), f\"Piano key with data-testid '{key.get_attribute('data-testid')}' is not visible.\"\n    time.sleep(1)\n\n@then(\"each piano key should display its corresponding keyboard key label\")\ndef step_then_piano_keys_display_labels(context):\n    # Get all piano keys\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    # Expected labels\n    expected_labels = ['a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';']\n    # Assert that each key displays the correct label\n    for key, expected_label in zip(piano_keys, expected_labels):\n        actual_label = key.find_element(By.TAG_NAME, \"span\").text.strip()\n        assert actual_label.lower() == expected_label.lower(), f\"Expected label '{expected_label}', but got '{actual_label}' for key '{key.get_attribute('data-testid')}'.\"\n    time.sleep(1)\n\n@then(\"the labels should be 'a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';'\")\ndef step_then_labels_match_expected(context):\n    # Get all piano keys\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    # Expected labels\n    expected_labels = ['a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';']\n    # Assert that the labels match the expected values\n    for key, expected_label in zip(piano_keys, expected_labels):\n        actual_label = key.find_element(By.TAG_NAME, \"span\").text.strip()\n        assert actual_label.lower() == expected_label.lower(), f\"Expected label '{expected_label}', but got '{actual_label}' for key '{key.get_attribute('data-testid')}'.\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    # Close the browser driver after the scenario\n    context.driver.quit()"
                }
            ]
        },
        "6": {
            "requirement": {
                "description": "The system must allow users to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\nScenario: [Normal] Playing a piano key using a mouse click\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on the white piano key with data-testid \"piano-key-a\"\n    Then the audio should play\n    And the piano key with data-testid \"piano-key-a\" should briefly have the \"active\" class applied\n    And the \"active\" class should be removed after 150 milliseconds"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the webpage is loaded and the piano keys are visible')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    time.sleep(1)\n\n@when('the user clicks on the white piano key with data-testid \"piano-key-a\"')\ndef step_when_user_clicks_piano_key(context):\n    piano_key_a = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    piano_key_a.click()\n\n@then('the audio should play')\ndef step_then_audio_should_play(context):\n    # Assuming audio play can be verified by checking the active class\n    pass\n\n@then('the piano key with data-testid \"piano-key-a\" should briefly have the \"active\" class applied')\ndef step_then_active_class_applied(context):\n    piano_key_a = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    assert \"active\" in piano_key_a.get_attribute(\"class\"), \"Active class not applied\"\n\n@then('the \"active\" class should be removed after 150 milliseconds')\ndef step_then_active_class_removed(context):\n    time.sleep(0.15)  # Wait for 150 milliseconds\n    piano_key_a = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    assert \"active\" not in piano_key_a.get_attribute(\"class\"), \"Active class not removed after 150 milliseconds\"\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\nScenario: [Normal] Playing a piano key using a keyboard press\n    Given the webpage is loaded and the piano keys are visible\n    When the user presses the \"a\" key on the keyboard\n    Then the audio should play\n    And the piano key with data-testid \"piano-key-a\" should briefly have the \"active\" class applied\n    And the \"active\" class should be removed after 150 milliseconds"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_active(element):\n    \"\"\"Helper function to check if the 'active' class is applied.\"\"\"\n    class_list = element.get_attribute(\"class\").split()\n    return \"active\" in class_list\n\n@given(\"the webpage is loaded and the piano keys are visible\")\ndef step_given_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    # Ensure piano keys are visible\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    for key in piano_keys:\n        assert key.is_displayed(), f\"Piano key {key.get_attribute('data-testid')} is not visible\"\n\n@when('the user presses the \"a\" key on the keyboard')\ndef step_when_user_presses_key(context):\n    # Simulate pressing the \"a\" key\n    context.driver.execute_script(\"document.dispatchEvent(new KeyboardEvent('keydown', {'key': 'a'}));\")\n\n\n@then(\"the audio should play\")\ndef step_then_audio_should_play(context):\n    # Check if the audio source has been updated to play the \"a.wav\" file\n    pass\n\n@then('the piano key with data-testid \"piano-key-a\" should briefly have the \"active\" class applied')\ndef step_then_key_has_active_class(context):\n    # Locate the piano key with data-testid \"piano-key-a\"\n    piano_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    assert is_active(piano_key), \"The 'active' class was not applied to the piano key\"\n\n@then('the \"active\" class should be removed after 150 milliseconds')\ndef step_then_active_class_removed(context):\n    # Wait for 150 milliseconds and check if the \"active\" class is removed\n    time.sleep(0.15)\n    piano_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-a']\")\n    assert not is_active(piano_key), \"The 'active' class was not removed from the piano key\"\n\n# Cleanup after tests\ndef after_scenario(context, scenario):\n    if hasattr(context, \"driver\"):\n        context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\n  Scenario: [Edge] Playing a black piano key using a mouse click\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on the black piano key with data-testid \"piano-key-w\"\n    Then the audio should play\n    And the piano key with data-testid \"piano-key-w\" should briefly have the \"active\" class applied\n    And the \"active\" class should be removed after 150 milliseconds\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nimport time\n\n@given(u'the webpage is loaded and the piano keys are visible')\ndef step_impl(context):\n    # Initialize the Selenium WebDriver\n    context.driver = webdriver.Chrome()\n    file_path = \"index.html\"\n    context.driver.get(f\"file://index.html\")\n    context.driver.implicitly_wait(5)\n    \n    # Verify that the piano keys are visible\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    assert len(piano_keys) > 0, \"Piano keys are not visible on the webpage.\"\n\n@when(u'the user clicks on the black piano key with data-testid \"piano-key-w\"')\ndef step_impl(context):\n    # Locate the black piano key with data-testid \"piano-key-w\" and click it\n    black_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    black_key.click()\n\n@then(u'the audio should play')\ndef step_impl(context):\n    # Verify that the audio file \"tunes/w.wav\" is played\n    pass\n\n@then(u'the piano key with data-testid \"piano-key-w\" should briefly have the \"active\" class applied')\ndef step_impl(context):\n    # Verify that the piano key has the \"active\" class applied\n    black_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    assert \"active\" in black_key.get_attribute(\"class\"), \"The 'active' class was not applied to the piano key.\"\n\n@then(u'the \"active\" class should be removed after 150 milliseconds')\ndef step_impl(context):\n    # Wait for 150 milliseconds and verify that the \"active\" class is removed\n    time.sleep(0.15)\n    black_key = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    assert \"active\" not in black_key.get_attribute(\"class\"), \"The 'active' class was not removed after 150 milliseconds.\"\n\n# Ensure the driver is closed at the end of the test\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\n  Scenario: [Edge] Playing a black piano key using a keyboard press\n    Given the webpage is loaded and the piano keys are visible\n    When the user presses the \"w\" key on the keyboard\n    Then the audio should play\n    And the piano key with data-testid \"piano-key-w\" should briefly have the \"active\" class applied\n    And the \"active\" class should be removed after 150 milliseconds\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_active(element):\n    class_list = element.get_attribute(\"class\").split()\n    return \"active\" in class_list\n\n@given('the webpage is loaded and the piano keys are visible')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='piano-key-w']\"))\n    )\n    time.sleep(1)\n\n@when('the user presses the \"w\" key on the keyboard')\ndef step_when_user_presses_key(context):\n    context.driver.find_element(By.CSS_SELECTOR, \"body\").send_keys(\"w\")\n\n\n@then('the audio should play')\ndef step_then_audio_file_should_play(context):\n    # This step would require a mock or a spy to verify audio playback, which is not directly possible with Selenium.\n    # Placeholder for audio verification logic\n    pass\n\n@then('the piano key with data-testid \"piano-key-w\" should briefly have the \"active\" class applied')\ndef step_then_key_should_have_active_class(context):\n    key_element = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    assert is_active(key_element), \"Expected 'active' class to be applied to the key\"\n    time.sleep(0.15)\n\n@then('the \"active\" class should be removed after 150 milliseconds')\ndef step_then_active_class_removed(context):\n    key_element = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='piano-key-w']\")\n    time.sleep(0.15)  # Wait for the class to be removed\n    assert not is_active(key_element), \"Expected 'active' class to be removed from the key\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\n  Scenario: [Error] Pressing a non-piano key on the keyboard\n    Given the webpage is loaded and the piano keys are visible\n    When the user presses the \"z\" key on the keyboard\n    Then no audio file should play\n    And no piano key should have the \"active\" class applied\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n# Background setup\n@given(\"the webpage is loaded and the piano keys are visible\")\ndef step_given_webpage_loaded(context):\n    # Initialize the WebDriver\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    \n    # Wait for the piano keys to be visible\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_all_elements_located((By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\"))\n    )\n    time.sleep(1)  # Ensure stability after loading\n\n@when('the user presses the \"z\" key on the keyboard')\ndef step_when_user_presses_non_piano_key(context):\n    # Simulate pressing the 'z' key\n    context.driver.execute_script(\"document.dispatchEvent(new KeyboardEvent('keydown', {'key': 'z'}));\")\n    time.sleep(1)  # Allow time for any potential event handling\n\n@then(\"no audio file should play\")\ndef step_then_no_audio_file_should_play(context):\n    # Check if the audio element's src attribute remains unchanged\n    audio_element = context.driver.execute_script(\"return document.querySelector('audio');\")\n    assert audio_element is None or audio_element.src == \"\", \"Audio file should not play\"\n\n@then('no piano key should have the \"active\" class applied')\ndef step_then_no_piano_key_active_class(context):\n    # Verify no piano key has the 'active' class\n    active_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key.active\")\n    assert len(active_keys) == 0, \"No piano key should have the 'active' class applied\"\n\n# Teardown\ndef after_scenario(context, scenario):\n    # Close the browser driver\n    if hasattr(context, \"driver\"):\n        context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Interacting with piano keys using mouse clicks and keyboard presses\n  The system must allow the user to interact with the piano keys using both mouse clicks and keyboard presses, ensuring consistent functionality across both input methods.\n\n\n  Scenario: [Error] Clicking outside the piano keys\n    Given the webpage is loaded and the piano keys are visible\n    When the user clicks on an area outside the piano keys\n    Then no audio file should play\n    And no piano key should have the \"active\" class applied"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_active(element):\n    class_list = element.get_attribute(\"class\").split()\n    return \"active\" in class_list\n\n@given(\"the webpage is loaded and the piano keys are visible\")\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='piano-key-a']\"))\n    )\n    time.sleep(1)\n\n@when(\"the user clicks on an area outside the piano keys\")\ndef step_when_click_outside_piano_keys(context):\n    # Assuming clicking on the header as an area outside the piano keys\n    header = context.driver.find_element(By.TAG_NAME, \"header\")\n    header.click()\n    time.sleep(1)\n\n@then(\"no audio file should play\")\ndef step_then_no_audio_file_play(context):\n    # This step requires validation that no audio is playing, which is complex without direct audio API access.\n    # Assuming we check that no key has the \"active\" class applied as a proxy for no audio playing.\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    assert all(not is_active(key) for key in piano_keys), \"Expected no piano key to be active\"\n\n@then('no piano key should have the \"active\" class applied')\ndef step_then_no_active_class_applied(context):\n    piano_keys = context.driver.find_elements(By.CSS_SELECTOR, \".piano-keys .key[data-testid^='piano-key']\")\n    assert all(not is_active(key) for key in piano_keys), \"Expected no piano key to have 'active' class\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        }
    }
}