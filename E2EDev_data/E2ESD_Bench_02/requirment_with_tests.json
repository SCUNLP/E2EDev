{
    "summary": {
        "overview": "The Notes App allows users to create, edit, and delete notes. Users can add new notes, edit existing ones using a toggle between a textarea and a display mode, and delete notes. The application uses localStorage to persist notes across sessions.",
        "predefined_options": "The application does not have predefined options for note content; users start with an empty note or edit existing ones.",
        "external_resources": "Font Awesome icons for buttons (plus, edit, delete) sourced from a CDN.",
        "external_js_libraries": "Marked.js for Markdown rendering, sourced from a CDN."
    },
    "finegrained_rewith_test": {
        "1": {
            "requirement": {
                "description": "When the user clicks the \"Add note\" button (id=\"add\", class=\"add\", data-testid=\"add-note-button\"), a new note is created and appended to the document body as a <div> element with the class \"note\". Inside each note, there is a visible, empty <textarea> (data-testid=\"note-textarea\") for user input. The application supports multiple rapid clicks on the \"Add note\" button, with each click creating a separate note, each containing its own textarea."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Note Creation\n  The user can create a new note by clicking the 'Add note' button, which displays a new note with an empty textarea for input.\n\n\n  Scenario: [Normal] User clicks 'Add note' button to create a new note\n    Given the Notes App page is loaded\n    When the user clicks the 'Add note' button with data-testid 'add-note-button'\n    Then a new note is displayed on the page\n    And the new note contains an empty textarea with data-testid 'note-textarea'\n    And the textarea is visible\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the Notes App page is loaded\")\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@when(\"the user clicks the 'Add note' button with data-testid 'add-note-button'\")\ndef step_when_user_clicks_add_note_button(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)  # Allow time for the note to be added\n\n@then(\"a new note is displayed on the page\")\ndef step_then_new_note_displayed(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \".note\")\n    assert len(notes) > 0, \"No new note was displayed on the page\"\n\n@then(\"the new note contains an empty textarea with data-testid 'note-textarea'\")\ndef step_then_note_contains_empty_textarea(context):\n    textarea = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")\n    assert textarea.get_attribute(\"value\") == \"\", \"The textarea is not empty\"\n\n@then(\"the textarea is visible\")\ndef step_then_textarea_is_visible(context):\n    textarea = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")\n    assert textarea.is_displayed(), \"The textarea is not visible\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Note Creation\n  The user can create a new note by clicking the 'Add note' button, which displays a new note with an empty textarea for input.\n\n\n  Scenario: [Edge] User clicks 'Add note' button multiple times quickly\n    Given the Notes App page is loaded\n    When the user clicks the 'Add note' button with data-testid 'add-note-button' rapidly\n    Then multiple new notes are displayed on the page\n    And each new note contains an empty textarea with data-testid 'note-textarea'\n    And all textareas are visible\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when(\"the user clicks the 'Add note' button with data-testid 'add-note-button' rapidly\")\ndef step_when_user_clicks_add_note_button_rapidly(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    for _ in range(5):  # Simulate rapid clicks\n        add_note_button.click()\n        time.sleep(0.2)  # Short delay between clicks\n\n@then('multiple new notes are displayed on the page')\ndef step_then_multiple_new_notes_displayed(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")\n    assert len(notes) > 1, f\"Expected multiple notes, but found {len(notes)}\"\n\n@then('each new note contains an empty textarea with data-testid \\'note-textarea\\'')\ndef step_then_each_note_contains_empty_textarea(context):\n    textareas = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")\n    for textarea in textareas:\n        assert textarea.get_attribute('value') == \"\", \"Expected empty textarea\"\n\n@then('all textareas are visible')\ndef step_then_all_textareas_visible(context):\n    textareas = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")\n    for textarea in textareas:\n        assert textarea.is_displayed(), \"Expected textarea to be visible\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "2": {
            "requirement": {
                "description": "The Notes App must allow users to edit notes with Markdown rendering support. When editing a note, the user interacts with a textarea (data-testid=\"note-textarea\") where they can input or modify Markdown content. As the user types Markdown (e.g., # Heading, **bold**, _italic_, [link](...)), the content is dynamically rendered in the main display area (data-testid=\"note-main\") in real-time, with proper HTML formatting (e.g., **Bold** becomes <strong>Bold</strong>). The app should handle complex Markdown syntax, ensuring that even invalid Markdown (e.g., unmatched **) does not cause crashes or errors, and instead displays the raw input when the user exits the edit mode by clicking the \"Edit\" button (data-testid=\"edit-note-button\"). All changes should be reflected immediately in local storage to persist the current state of the note."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Markdown Rendering in Notes\n  The application should render the content typed into the textarea of a note in Markdown format in the main display area.\n\n\nScenario: [Normal] User types Markdown content into the note's textarea\n    Given the Notes App page is loaded\n    And the user clicks the 'Add note' button with data-testid 'add-note-button' to add a new note\n    When the user enters \"# Heading\" into the textarea with data-testid \"note-textarea\"\n    And The user clicks the \"Edit\" button with data-testid \"edit-note-button\" to exit edit mode\n    Then the main display area with data-testid \"note-main\" should render \"<h1>Heading</h1>\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\nfrom bs4 import BeautifulSoup\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@given(\"the user clicks the 'Add note' button with data-testid 'add-note-button' to add a new note\")\ndef step_given_user_clicks_add_note_button(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)  # Allow time for the note to be added\n\n@when('the user enters \"# Heading\" into the textarea with data-testid \"note-textarea\"')\ndef step_when_user_enters_markdown_in_textarea(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    textarea.clear()\n    textarea.send_keys(\"# Heading\")\n    time.sleep(1)  # Allow time for the input to be processed\n\n@when('The user clicks the \"Edit\" button with data-testid \"edit-note-button\" to exit edit mode')\ndef step_when_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@then('the main display area with data-testid \"note-main\" should render \"<h1>Heading</h1>\"')\ndef step_then_main_display_area_renders_heading(context):\n    main_display = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    rendered_html = main_display.get_attribute(\"innerHTML\").strip()\n    expected_html = \"<h1>Heading</h1>\"\n    # 解析实际的 HTML 内容\n    rendered_soup = BeautifulSoup(rendered_html, 'html.parser')\n    expected_soup = BeautifulSoup(expected_html, 'html.parser')\n\n    # 查找 h1 标签并检查其文本内容\n    h1_tag = rendered_soup.find('h1')\n    expected_text = expected_soup.h1.text\n\n    assert h1_tag and h1_tag.text == expected_text, f\"Expected text '{expected_text}' but got '{rendered_html}'\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Markdown Rendering in Notes\n  The application should render the content typed into the textarea of a note in Markdown format in the main display area.\n\n\n  Scenario: [Edge] User types complex Markdown content into the note's textarea\n    Given the Notes App page is loaded\n    And a note is present with a textarea having data-testid \"note-textarea\"\n    When the user enters \"**Bold** and _italic_ text with [link](http://example.com)\" into the textarea with data-testid \"note-textarea\"\n    And the user 'Edit' button with data-testid 'edit-note-button' to exit edit mode\n    Then the main display area with data-testid \"note-main\" should render \"<strong>Bold</strong> and <em>italic</em> text with <a href='http://example.com'>link</a>\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\nfrom bs4 import BeautifulSoup\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('a note is present with a textarea having data-testid \"note-textarea\"')\ndef step_given_note_with_textarea(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)\n\n@when('the user enters \"**Bold** and _italic_ text with [link](http://example.com)\" into the textarea with data-testid \"note-textarea\"')\ndef step_when_user_enters_markdown(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    textarea.clear()\n    textarea.send_keys(\"**Bold** and _italic_ text with [link](http://example.com)\")\n    time.sleep(1)\n\n@when(\"the user 'Edit' button with data-testid 'edit-note-button' to exit edit mode\")\ndef step_when_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@then('the main display area with data-testid \"note-main\" should render \"<strong>Bold</strong> and <em>italic</em> text with <a href=\\'http://example.com\\'>link</a>\"')\ndef step_then_main_display_renders_markdown(context):\n    main_display = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    expected_html = \"<strong>Bold</strong> and <em>italic</em> text with <a href='http://example.com'>link</a>\"\n    # 解析实际的 HTML 内容\n    rendered_html = main_display.get_attribute(\"innerHTML\").strip()\n    rendered_soup = BeautifulSoup(rendered_html, 'html.parser')\n    expected_soup = BeautifulSoup(expected_html, 'html.parser')\n\n    # 检查实际内容与预期内容\n    # 检查加粗和链接\n    assert rendered_soup.find('strong') and rendered_soup.find('strong').text == expected_soup.find(\n        'strong').text, \"Bold text is missing or incorrect\"\n    assert rendered_soup.find('em') and rendered_soup.find('em').text == expected_soup.find(\n        'em').text, \"Italic text is missing or incorrect\"\n    assert rendered_soup.find('a') and rendered_soup.find('a')['href'] == expected_soup.find('a')[\n        'href'], \"Link is missing or incorrect\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Markdown Rendering in Notes\n  The application should render the content typed into the textarea of a note in Markdown format in the main display area.\n\n\nScenario: [Error] User types invalid Markdown syntax into the note's textarea\n    Given the Notes App page is loaded\n    And the user click the button with data-testid 'add-note-button' to add a new note\n    When the user enters \"This is not **valid Markdown\" into the textarea with data-testid \"note-textarea\"\n    And the user clicks the 'Edit' button with data-testid 'edit-note-button' to exit edit mode\n    Then the main display area with data-testid \"note-main\" should render \"This is not **valid Markdown\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given(\"the user click the button with data-testid 'add-note-button' to add a new note\")\ndef step_given_user_clicks_add_note_button(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)\n\n@when('the user enters \"This is not **valid Markdown\" into the textarea with data-testid \"note-textarea\"')\ndef step_when_user_enters_text_into_textarea(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    textarea.clear()\n    textarea.send_keys(\"This is not **valid Markdown\")\n    time.sleep(1)\n\n@when(\"the user clicks the 'Edit' button with data-testid 'edit-note-button' to exit edit mode\")\ndef step_when_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@then('the main display area with data-testid \"note-main\" should render \"This is not **valid Markdown\"')\ndef step_then_main_display_area_should_render_text(context):\n    main_display_area = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    rendered_text = main_display_area.text\n    expected_text = \"This is not **valid Markdown\"\n    assert expected_text in rendered_text, f\"Expected '{expected_text}' in '{rendered_text}'\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "3": {
            "requirement": {
                "description": "The Notes App must allow users to create and manage notes with seamless view and edit functionality. When the app page loads, users can create a new note by clicking the \"Add note\" button (data-testid=\"add-note-button\"). Upon creation, the note should immediately enter edit mode: the textarea (data-testid=\"note-textarea\") is visible for user input, while the main content area (data-testid=\"note-main\") remains hidden. Users can switch between edit and view modes by clicking the \"Edit\" button (data-testid=\"edit-note-button\"). In view mode, the main content area becomes visible to display the formatted content, and the textarea is hidden; in edit mode, this behavior is reversed. All changes typed into the textarea should be automatically saved to local storage, preserving the note’s state across sessions."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Note Editing Functionality\n  The application should allow users to create notes that automatically enter edit mode upon creation. Users should be able to toggle between viewing and editing a note using the 'Edit' button.\n\n\n  Scenario: [Normal] Create a new note and verify it is in edit mode\n    Given the Notes App page is loaded\n    When the user clicks the \"Add note\" button with data-testid \"add-note-button\"\n    Then a new note should be created\n    And the note's textarea with data-testid \"note-textarea\" should be visible\n    And the note's main content area with data-testid \"note-main\" should be hidden\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when('the user clicks the \"Add note\" button with data-testid \"add-note-button\"')\ndef step_when_user_clicks_add_note_button(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)\n\n@then('a new note should be created')\ndef step_then_new_note_should_be_created(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \".note\")\n    assert len(notes) > 0, \"No new note was created\"\n\n@then('the note\\'s textarea with data-testid \"note-textarea\" should be visible')\ndef step_then_note_textarea_should_be_visible(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    assert textarea.is_displayed(), \"Textarea is not visible\"\n\n@then('the note\\'s main content area with data-testid \"note-main\" should be hidden')\ndef step_then_note_main_content_area_should_be_hidden(context):\n    main_content = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    assert not main_content.is_displayed(), \"Main content area is not hidden\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Note Editing Functionality\n  The application should allow users to create notes that automatically enter edit mode upon creation. Users should be able to toggle between viewing and editing a note using the 'Edit' button.\n\n\n  Scenario: [Normal] Toggle note from edit mode to view mode\n    Given the Notes App page is loaded\n    And a note is created with text \"Sample Note\"\n    When the user clicks the \"Edit\" button with data-testid \"edit-note-button\"\n    Then the note's textarea with data-testid \"note-textarea\" should be hidden\n    And the note's main content area with data-testid \"note-main\" should be visible\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('a note is created with text \"Sample Note\"')\ndef step_given_note_created_with_text(context):\n    add_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_button.click()\n    time.sleep(1)\n\n    text_area = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    text_area.send_keys(\"Sample Note\")\n    time.sleep(1)\n\n    # Trigger input event to update the main content\n    text_area.send_keys(\"\\n\")\n    time.sleep(1)\n\n@when('the user clicks the \"Edit\" button with data-testid \"edit-note-button\"')\ndef step_when_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@then('the note\\'s textarea with data-testid \"note-textarea\" should be hidden')\ndef step_then_note_textarea_should_be_hidden(context):\n    text_area = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    assert not is_visible(text_area), \"Expected textarea to be hidden\"\n\n@then('the note\\'s main content area with data-testid \"note-main\" should be visible')\ndef step_then_note_main_content_should_be_visible(context):\n    main_content = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    assert is_visible(main_content), \"Expected main content area to be visible\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Note Editing Functionality\n  The application should allow users to create notes that automatically enter edit mode upon creation. Users should be able to toggle between viewing and editing a note using the 'Edit' button.\n\n\nScenario: [Normal] Toggle note from view mode to edit mode\n    Given the Notes App page is loaded\n    And a note is created with text \"Sample Note\"\n    And the user clicks the \"Edit\" button with data-testid \"edit-note-button\"\n    When the user clicks the \"Edit\" button with data-testid \"edit-note-button\"\n    Then the note's textarea with data-testid \"note-textarea\" should be visible\n    And the note's main content area with data-testid \"note-main\" should be hidden"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('a note is created with text \"Sample Note\"')\ndef step_given_note_created_with_text(context):\n    add_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_button.click()\n    time.sleep(1)\n\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    textarea.send_keys(\"Sample Note\")\n    time.sleep(1)\n\n@given('the user clicks the \"Edit\" button with data-testid \"edit-note-button\"')\ndef step_given_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@when('the user clicks the \"Edit\" button with data-testid \"edit-note-button\"')\ndef step_when_user_clicks_edit_button(context):\n    edit_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='edit-note-button']\"))\n    )\n    edit_button.click()\n    time.sleep(1)\n\n@then('the note\\'s textarea with data-testid \"note-textarea\" should be visible')\ndef step_then_note_textarea_should_be_visible(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    assert textarea.is_displayed(), \"Textarea is not visible\"\n\n@then('the note\\'s main content area with data-testid \"note-main\" should be hidden')\ndef step_then_note_main_should_be_hidden(context):\n    main_content = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    assert not main_content.is_displayed(), \"Main content area is not hidden\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Note Editing Functionality\n  The application should allow users to create notes that automatically enter edit mode upon creation. Users should be able to toggle between viewing and editing a note using the 'Edit' button.\n\n\n  Scenario: [Edge] Create a note with empty content and verify edit mode\n    Given the Notes App page is loaded\n    When the user clicks the \"Add note\" button with data-testid \"add-note-button\"\n    Then a new note should be created\n    And the note's textarea with data-testid \"note-textarea\" should be visible\n    And the note's main content area with data-testid \"note-main\" should be hidden\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when('the user clicks the \"Add note\" button with data-testid \"add-note-button\"')\ndef step_when_user_clicks_add_note_button(context):\n    add_note_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_note_button.click()\n    time.sleep(1)\n\n@then('a new note should be created')\ndef step_then_new_note_should_be_created(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \".note\")\n    assert len(notes) > 0, \"No new note was created\"\n    time.sleep(1)\n\n@then('the note\\'s textarea with data-testid \"note-textarea\" should be visible')\ndef step_then_note_textarea_should_be_visible(context):\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    assert textarea.is_displayed(), \"Textarea is not visible\"\n    time.sleep(1)\n\n@then('the note\\'s main content area with data-testid \"note-main\" should be hidden')\ndef step_then_note_main_content_area_should_be_hidden(context):\n    main_content = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    assert not main_content.is_displayed(), \"Main content area is not hidden\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "4": {
            "requirement": {
                "description": "When the user interacts with the Notes App, they should be able to delete a note by clicking the \"Delete\" button associated with that note (data-testid=\"delete-note-button\"). Upon clicking this button, the targeted note must be immediately removed from the DOM so it no longer appears on the page, and the corresponding entry must also be removed from localStorage to ensure it is no longer part of the stored notes array."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Note Deletion\n  The user can delete a note, which removes it from the page and updates localStorage accordingly.\n\n\nScenario: [Normal] Delete a note successfully\n    Given the Notes App page is loaded\n    And a note is created with the text \"Sample Note\"\n    When the user clicks the 'Delete' button with data-testid 'delete-note-button'\n    Then the note is removed from the page\n    And localStorage does not contain \"Sample Note\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the Notes App page is loaded\")\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given(\"a note is created with the text \\\"Sample Note\\\"\")\ndef step_given_note_created(context):\n    add_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n    )\n    add_button.click()\n    time.sleep(1)\n\n    textarea = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-textarea']\"))\n    )\n    textarea.send_keys(\"Sample Note\")\n    time.sleep(1)\n\n@when(\"the user clicks the 'Delete' button with data-testid 'delete-note-button'\")\ndef step_when_user_clicks_delete_button(context):\n    delete_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='delete-note-button']\"))\n    )\n    delete_button.click()\n    time.sleep(1)\n\n@then(\"the note is removed from the page\")\ndef step_then_note_removed_from_page(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \".note\")\n    assert len(notes) == 0, \"Expected no notes on the page\"\n\n@then(\"localStorage does not contain \\\"Sample Note\\\"\")\ndef step_then_localstorage_does_not_contain_sample_note(context):\n    notes = context.driver.execute_script(\"return localStorage.getItem('notes');\")\n    assert \"Sample Note\" not in notes, \"Expected 'Sample Note' not to be in localStorage\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Note Deletion\n  The user can delete a note, which removes it from the page and updates localStorage accordingly.\n\n\nScenario: [Edge] Delete a note when multiple notes are present\n    Given the Notes App page is loaded\n    And  multiple notes are created with texts \"Note 1\", \"Note 2\", \"Note 3\"\n    When the user clicks the 'Delete' button on the note with text \"Note 2\"\n    Then the note with text \"Note 2\" is removed from the page\n    And localStorage contains \"Note 1\" and \"Note 3\" but not \"Note 2\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Notes App page is loaded')\ndef step_given_notes_app_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('multiple notes are created with texts \"Note 1\", \"Note 2\", \"Note 3\"')\ndef step_given_multiple_notes_created(context):\n    notes = [\"Note 1\", \"Note 2\", \"Note 3\"]\n    for note in notes:\n        add_button = WebDriverWait(context.driver, 10).until(\n            EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='add-note-button']\"))\n        )\n        add_button.click()\n        time.sleep(1)\n        text_area = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-textarea']\")[-1]\n        text_area.send_keys(note)\n        time.sleep(1)\n        # Toggle to save the note\n        edit_button = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='edit-note-button']\")[-1]\n        edit_button.click()\n        time.sleep(1)\n\n@when('the user clicks the \\'Delete\\' button on the note with text \"Note 2\"')\ndef step_when_user_deletes_note_2(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \".note\")\n    for note in notes:\n        main = note.find_element(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n        if \"Note 2\" in main.text:\n            delete_button = note.find_element(By.CSS_SELECTOR, \"[data-testid='delete-note-button']\")\n            delete_button.click()\n            time.sleep(1)\n            break\n\n@then('the note with text \"Note 2\" is removed from the page')\ndef step_then_note_2_removed_from_page(context):\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    note_texts = [note.text for note in notes]\n    assert \"Note 2\" not in note_texts, \"Note 2 was not removed from the page\"\n\n@then('localStorage contains \"Note 1\" and \"Note 3\" but not \"Note 2\"')\ndef step_then_local_storage_updated(context):\n    local_storage_notes = context.driver.execute_script(\"return JSON.parse(localStorage.getItem('notes'));\")\n    assert \"Note 1\" in local_storage_notes, \"Note 1 is not in localStorage\"\n    assert \"Note 3\" in local_storage_notes, \"Note 3 is not in localStorage\"\n    assert \"Note 2\" not in local_storage_notes, \"Note 2 is still in localStorage\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "5": {
            "requirement": {
                "description": "When the Notes App webpage loads, it must retrieve all saved notes from localStorage and display them accordingly. For each stored note, the app should dynamically create a div element with the class note, which includes a div with the class tools containing an \"Edit\" button (data-testid=\"edit-note-button\") and a \"Delete\" button (data-testid=\"delete-note-button\"). Each note must also include a div with the class main (data-testid=\"note-main\") to show the note content, and a textarea (data-testid=\"note-textarea\") for editing. Notes retrieved from localStorage should be rendered with their content displayed in the main div, with the textarea hidden by default. For notes that have no content, the application should instead show the textarea and hide the main div, allowing immediate editing. If localStorage is empty, no notes should be shown. Internally, the notes variable is used to store the array of note content, retrieved using JSON.parse(localStorage.getItem('notes'))."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Display stored notes on page load\n  The application should retrieve and display any notes stored in localStorage when the page loads.\n\n\n  Scenario: [Normal] Display notes from localStorage on page load\n    Given the localStorage contains notes with values \"Note 1\" and \"Note 2\"\n    When the user opens the Notes App webpage\n    Then the page should display a note with text \"Note 1\" in a div with data-testid \"note-main\"\n    And the page should display a note with text \"Note 2\" in a div with data-testid \"note-main\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\nimport json\n\nfile_path = \"index.html\"\n\n@given('the localStorage contains notes with values \"Note 1\" and \"Note 2\"')\ndef step_given_localstorage_contains_notes(context):\n    # Initialize the WebDriver\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n\n    # Inject notes into localStorage\n    notes = [\"Note 1\", \"Note 2\"]\n    context.driver.execute_script(\"window.localStorage.setItem('notes', arguments[0]);\", json.dumps(notes))\n    time.sleep(1)\n\n@when('the user opens the Notes App webpage')\ndef step_when_user_opens_notes_app(context):\n    # Refresh the page to load notes from localStorage\n    context.driver.refresh()\n    time.sleep(1)\n\n@then('the page should display a note with text \"Note 1\" in a div with data-testid \"note-main\"')\ndef step_then_display_note_1(context):\n    # Wait for the note to be displayed\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    # Verify the note text\n    note_elements = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    note_texts = [note.text for note in note_elements]\n    assert any(\"Note 1\" in note_text for note_text in note_texts), \"Note 1 not found in displayed notes\"\n\n@then('the page should display a note with text \"Note 2\" in a div with data-testid \"note-main\"')\ndef step_then_display_note_2(context):\n    # Wait for the note to be displayed\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='note-main']\"))\n    )\n    # Verify the note text\n    note_elements = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    note_texts = [note.text for note in note_elements]\n    assert any(\"Note 2\" in note_text for note_text in note_texts), \"Note 2 not found in displayed notes\"\n\ndef after_scenario(context, scenario):\n    # Close the browser after each scenario\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Display stored notes on page load\n  The application should retrieve and display any notes stored in localStorage when the page loads.\n\n\n  Scenario: [Edge] Display no notes when localStorage is empty\n    Given the localStorage is empty\n    When the user opens the Notes App webpage\n    Then no notes should be displayed on the page\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef setup_driver(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n\ndef teardown_driver(context):\n    context.driver.quit()\n\n@given('the localStorage is empty')\ndef step_given_localstorage_is_empty(context):\n    setup_driver(context)\n    context.driver.execute_script(\"window.localStorage.clear();\")\n    time.sleep(1)\n\n@when('the user opens the Notes App webpage')\ndef step_when_user_opens_notes_app(context):\n    # The page is already opened in the setup step\n    pass\n\n@then('no notes should be displayed on the page')\ndef step_then_no_notes_displayed(context):\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"body\"))\n    )\n    notes = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='note-main']\")\n    assert len(notes) == 0, f\"Expected no notes, but found {len(notes)}\"\n    teardown_driver(context)"
                }
            ]
        }
    }
}