{
    "summary": {
        "overview": "The Meal Finder application allows users to search for meals by keywords, view detailed information about specific meals, and fetch random meals. The application dynamically updates the UI based on user interactions and API responses.",
        "predefined_options": "Default behavior includes fetching and displaying a random meal when the page loads or when the 'Random' button is clicked.",
        "external_resources": [
            {
                "name": "Meal Finder Logo",
                "source": "https://i.ibb.co/ZKCTJ9b/728985-fish-cooking-food-kitchen-meal-icon.png"
            },
            {
                "name": "Meal Images",
                "source": "Fetched dynamically from TheMealDB API"
            }
        ],
        "external_js_libraries": [
            {
                "name": "Font Awesome",
                "source": "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
            }
        ]
    },
    "finegrained_rewith_test": {
        "1": {
            "requirement": {
                "description": "The Meal Finder web application must allow users to search for meals by entering a keyword into the search input field identified by the attribute data-testid 'search-input'. Upon clicking the search button with data-testid 'search-button', the application should fetch meals matching the keyword from the API and display them within the meals container with data-testid 'meals-container'. The result heading with data-testid 'result-heading' should update to show 'Search results for \"<keyword>\":'. If no matching meals are found, the meals container should be cleared, and the result heading should display 'No results found. Try another keyword!'. In the case of an empty keyword, the application should automatically fetch and display a random meal in the single meal container with data-testid 'single-meal-container', leaving the result heading empty. Additionally, clicking on a meal within the meals container should navigate to detailed meal information, fetched using the meal's ID, and displayed in the single meal container, ensuring smooth scrolling into view."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Search for meals using a keyword\n  The user can search for meals by typing a keyword into the search input field and clicking the search button. The system fetches meals matching the keyword from the API and displays them. If no results are found, a message is displayed.\n\n\n  Scenario: [Normal] Search for meals with a valid keyword\n    Given the Meal Finder webpage is loaded\n    And the search input field with data-testid \"search-input\" is visible\n    When the user enters \"chicken\" into the search input field with data-testid \"search-input\"\n    And clicks the search button with data-testid \"search-button\"\n    Then the system fetches meals matching the keyword \"chicken\" from the API\n    And displays the meals in the meals container with data-testid \"meals-container\"\n    And the result heading with data-testid \"result-heading\" shows \"Search results for \"chicken\":\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Meal Finder webpage is loaded')\ndef step_given_meal_finder_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert search_input.is_displayed(), \"Search input field is not visible\"\n    time.sleep(1)\n\n@when('the user enters \"chicken\" into the search input field with data-testid \"search-input\"')\ndef step_when_user_enters_keyword(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    search_input.send_keys(\"chicken\")\n    time.sleep(1)\n\n@when('clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the system fetches meals matching the keyword \"chicken\" from the API')\ndef step_then_system_fetches_meals(context):\n    # Assuming the meals are fetched and displayed, we check for the presence of meal elements\n    meals_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='meals-container']\"))\n    )\n    meals = meals_container.find_elements(By.CSS_SELECTOR, \".meal\")\n    assert len(meals) > 0, \"No meals found matching the keyword 'chicken'\"\n    time.sleep(1)\n\n@then('displays the meals in the meals container with data-testid \"meals-container\"')\ndef step_then_displays_meals(context):\n    meals_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='meals-container']\")\n    assert meals_container.is_displayed(), \"Meals container is not visible\"\n    time.sleep(1)\n\n@then('the result heading with data-testid \"result-heading\" shows \"Search results for \"chicken\":\"')\ndef step_then_result_heading_shows(context):\n    result_heading = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-heading']\")\n    expected_text = \"Search results for \\\"chicken\\\":\"\n    assert expected_text.lower() in result_heading.text.lower() or \"chicken\" in result_heading.text.lower(), f\"Expected '{expected_text}' in '{result_heading.text}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Search for meals using a keyword\n  The user can search for meals by typing a keyword into the search input field and clicking the search button. The system fetches meals matching the keyword from the API and displays them. If no results are found, a message is displayed.\n\n\n  Scenario: [Edge] Search for meals with a keyword that has no matching results\n    Given the Meal Finder webpage is loaded\n    And the search input field with data-testid \"search-input\" is visible\n    When the user enters \"xyzabc\" into the search input field with data-testid \"search-input\"\n    And clicks the search button with data-testid \"search-button\"\n    Then the system fetches meals matching the keyword \"xyzabc\" from the API\n    And the meals container with data-testid \"meals-container\" is empty\n    And the result heading with data-testid \"result-heading\" shows \"No results found. Try another keyword!\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Meal Finder webpage is loaded')\ndef step_given_meal_finder_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert search_input.is_displayed(), \"Search input field is not visible\"\n    time.sleep(1)\n\n@when('the user enters \"xyzabc\" into the search input field with data-testid \"search-input\"')\ndef step_when_user_enters_keyword(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    search_input.send_keys(\"xyzabc\")\n    time.sleep(1)\n\n@when('clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the system fetches meals matching the keyword \"xyzabc\" from the API')\ndef step_then_system_fetches_meals(context):\n    # This step is more about verifying the action was performed, which is covered in the next steps.\n    time.sleep(1)\n\n@then('the meals container with data-testid \"meals-container\" is empty')\ndef step_then_meals_container_empty(context):\n    meals_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='meals-container']\")\n    assert meals_container.text.strip() == \"\", \"Meals container is not empty\"\n    time.sleep(1)\n\n@then('the result heading with data-testid \"result-heading\" shows \"No results found. Try another keyword!\"')\ndef step_then_result_heading_shows_no_results(context):\n    result_heading = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-heading']\")\n    expected_text = \"No results found. Try another keyword!\"\n    assert expected_text.lower() in result_heading.text.lower(), f\"Expected '{expected_text}' in '{result_heading.text}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Search for meals using a keyword\n  The user can search for meals by typing a keyword into the search input field and clicking the search button. The system fetches meals matching the keyword from the API and displays them. If no results are found, a message is displayed.\n\n\n  Scenario: [Error] Search for meals with an empty keyword\n    Given the Meal Finder webpage is loaded\n    And the search input field with data-testid \"search-input\" is visible\n    When the user enters \"\" (empty string) into the search input field with data-testid \"search-input\"\n    And clicks the search button with data-testid \"search-button\"\n    Then the system fetches a random meal from the API\n    And displays the meal details in the single meal container with data-testid \"single-meal-container\"\n    And the result heading with data-testid \"result-heading\" is empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Meal Finder webpage is loaded')\ndef step_given_meal_finder_webpage_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow the page to load completely\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_given_search_input_field_visible(context):\n    # Wait for the search input field to be visible\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert search_input.is_displayed(), \"Search input field is not visible\"\n\n@when('the user enters \"\" (empty string) into the search input field with data-testid \"search-input\"')\ndef step_when_user_enters_empty_string(context):\n    # Locate the search input field and clear its content\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    time.sleep(1)  # Allow time for the input field to update\n\n@when('clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    # Locate and click the search button\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)  # Allow time for the button click action to complete\n\n@then('the system fetches a random meal from the API')\ndef step_then_system_fetches_random_meal(context):\n    # Wait for the single meal container to be populated\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.is_displayed(), \"Single meal container is not displayed\"\n\n@then('displays the meal details in the single meal container with data-testid \"single-meal-container\"')\ndef step_then_displays_meal_details(context):\n    # Validate that the single meal container contains meal details\n    single_meal_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='single-meal-container']\")\n    assert single_meal_container.text.strip() != \"\", \"Single meal container does not contain meal details\"\n\n@then('the result heading with data-testid \"result-heading\" is empty')\ndef step_then_result_heading_is_empty(context):\n    # Validate that the result heading is empty\n    result_heading = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-heading']\")\n    assert result_heading.text.strip() == \"\", \"Result heading is not empty\"\n\n# Teardown step to close the browser after the test\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "2": {
            "requirement": {
                "description": "When the user clicks the 'Random' button with data-testid 'random-button', the system must fetch a random meal from the API and display its details in the single meal container with data-testid 'single-meal-container'. The meals container with data-testid 'meals-container' and the result heading with data-testid 'result-heading' must be cleared. If the user clicks the 'Random' button multiple times in quick succession, the single meal container should display the latest meal details fetched, ensuring the result heading remains empty throughout."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Fetch and display a random meal\n  The system must fetch a random meal from the API and display its details in the single meal container when the user clicks the 'Random' button. The meals container and result heading must be cleared.\n\n\nScenario: [Normal] User clicks the 'Random' button to fetch a random meal\n    Given the Meal Finder page is loaded\n    When the user clicks the 'Random' button with data-testid \"random-button\"\n    Then the single meal container with data-testid \"single-meal-container\" should display the meal details\n    And the result heading with data-testid \"result-heading\" should remain empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n# Background: Initialize the browser and load the test page\n@given(\"the Meal Finder page is loaded\")\ndef step_given_meal_finder_page_loaded(context):\n    context.driver = webdriver.Chrome()  # Initialize the WebDriver\n    context.driver.maximize_window()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow the page to load completely\n\n@when('the user clicks the \\'Random\\' button with data-testid \"random-button\"')\ndef step_when_user_clicks_random_button(context):\n    random_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='random-button']\"))\n    )\n    random_button.click()\n    time.sleep(1)  # Wait for the interaction to complete\n\n@then('the single meal container with data-testid \"single-meal-container\" should display the meal details')\ndef step_then_single_meal_container_displays_meal_details(context):\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.is_displayed(), \"Single meal container is not visible\"\n    assert single_meal_container.text.strip() != \"\", \"Single meal container is empty\"\n\n@then('the result heading with data-testid \"result-heading\" should remain empty')\ndef step_then_result_heading_remains_empty(context):\n    result_heading = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-heading']\"))\n    )\n    assert result_heading.text.strip() == \"\", f\"Result heading is not empty: {result_heading.text.strip()}\"\n\n# Cleanup: Close the browser after the test\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Fetch and display a random meal\n  The system must fetch a random meal from the API and display its details in the single meal container when the user clicks the 'Random' button. The meals container and result heading must be cleared.\n\n\nScenario: [Edge] User clicks the 'Random' button multiple times in quick succession\n    Given the Meal Finder page is loaded\n    When the user clicks the 'Random' button with data-testid \"random-button\" multiple times quickly\n    Then the single meal container with data-testid \"single-meal-container\" should display the latest meal details fetched\n    And the result heading with data-testid \"result-heading\" should remain empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given(\"the Meal Finder page is loaded\")\ndef step_given_meal_finder_page_loaded(context):\n    # Initialize the WebDriver and load the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    time.sleep(1)  # Allow the page to load completely\n\n@when('the user clicks the \\'Random\\' button with data-testid \"random-button\" multiple times quickly')\ndef step_when_user_clicks_random_button_multiple_times(context):\n    # Locate the random button and click it multiple times\n    random_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='random-button']\"))\n    )\n    for _ in range(3):  # Simulate quick successive clicks\n        random_button.click()\n        time.sleep(1)  # Allow time for the API response and DOM update\n\n@then('the single meal container with data-testid \"single-meal-container\" should display the latest meal details fetched')\ndef step_then_single_meal_container_displays_latest_meal(context):\n    # Verify the single meal container displays content\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.is_displayed(), \"Single meal container is not visible\"\n    assert single_meal_container.text.strip() != \"\", \"Single meal container is empty\"\n\n@then('the result heading with data-testid \"result-heading\" should remain empty')\ndef step_then_result_heading_remains_empty(context):\n    # Verify the result heading is empty\n    result_heading = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-heading']\"))\n    )\n    assert result_heading.text.strip() == \"\", f\"Result heading is not empty: {result_heading.text.strip()}\"\n\n# Teardown to close the browser after tests\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                }
            ]
        },
        "3": {
            "requirement": {
                "description": "Upon clicking a meal element within the meals container (identified by data-testid 'meals-container'), the application must retrieve detailed information about the selected meal using its data-mealid attribute. The details, including the meal's name, image, category, area, ingredients, and instructions, must be displayed in the single meal container (identified by data-testid 'single-meal-container'). The page should then smoothly scroll to bring the single meal container into view. This interaction is triggered by a click event on any element with the class 'meal-info' within the meals container."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Display detailed information about a selected meal\n  The system must fetch and display detailed information about a selected meal when the user clicks on a meal element in the meals container. The page must scroll smoothly to the single meal container.\n\n\nScenario: [Normal] User clicks on a meal element to view its details\n    Given the Meal Finder page is loaded\n    And the user searches for the keyword \"chicken\"\n    And the meals are displayed in the meals container with data-testid \"meals-container\"\n    And each meal element has a valid data-mealid attribute\n    When the user clicks on a meal element\n    Then the system should fetch the details of the selected meal\n    And the single meal container with data-testid \"single-meal-container\" should display the meal's name, image, category, ingredients, and instructions\n    And the page should smoothly scroll to the single meal container"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the Meal Finder page is loaded')\ndef step_given_meal_finder_page_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the user searches for the keyword \"chicken\"')\ndef step_given_user_searches_for_keyword(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.send_keys(\"chicken\")\n    search_button = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-button']\")\n    search_button.click()\n    time.sleep(2)\n\n@given('the meals are displayed in the meals container with data-testid \"meals-container\"')\ndef step_given_meals_displayed(context):\n    meals_container = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='meals-container']\"))\n    )\n    assert meals_container.is_displayed(), \"Meals container is not displayed\"\n\n@given('each meal element has a valid data-mealid attribute')\ndef step_given_meal_elements_have_data_mealid(context):\n    meal_elements = context.driver.find_elements(By.CSS_SELECTOR, \"[data-testid='meals-container'] .meal-info\")\n    assert len(meal_elements) > 0, \"No meal elements found\"\n    for meal in meal_elements:\n        meal_id = meal.get_attribute(\"data-mealid\")\n        assert meal_id is not None and meal_id != \"\", \"Meal element does not have a valid data-mealid\"\n\n@when('the user clicks on a meal element')\ndef step_when_user_clicks_meal_element(context):\n    meal_element = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='meals-container'] .meal-info\")\n    meal_element.click()\n    time.sleep(2)\n\n@then('the system should fetch the details of the selected meal')\ndef step_then_system_fetches_meal_details(context):\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.is_displayed(), \"Single meal container is not displayed\"\n\n@then('the single meal container with data-testid \"single-meal-container\" should display the meal\\'s name, image, category, ingredients, and instructions')\ndef step_then_single_meal_container_displays_basic_info(context):\n    container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='single-meal-container']\")\n\n    name = container.find_element(By.TAG_NAME, \"h1\")\n    assert name.text.strip(), \"Meal name is missing\"\n\n    # 有图片\n    image = container.find_element(By.TAG_NAME, \"img\")\n    assert image.get_attribute(\"src\").strip(), \"Meal image src is missing\"\n\n    # 有至少一个 ingredient（ul > li）\n    ingredients = container.find_elements(By.CSS_SELECTOR, \"ul li\")\n    assert len(ingredients) > 0, \"No ingredients found\"\n\n    # 有 instructions 文本（找 p 标签）\n    instruction = container.find_element(By.TAG_NAME, \"p\")\n    assert instruction.text.strip(), \"No instructions text found\"\n\n@then('the page should smoothly scroll to the single meal container')\ndef step_then_page_scrolls_to_single_meal_container(context):\n    single_meal_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='single-meal-container']\")\n    is_visible = context.driver.execute_script(\"return arguments[0].offsetWidth > 0 && arguments[0].offsetHeight > 0;\", single_meal_container)\n    assert is_visible, \"Single meal container is not visible after scrolling\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "4": {
            "requirement": {
                "description": "When the 'Meal Finder' webpage loads, the system must automatically fetch a random meal from the MealDB API using the endpoint 'https://www.themealdb.com/api/json/v1/1/random.php'. The fetched meal must be displayed in the 'single meal container' (identified by the attribute data-testid='single-meal-container'). The displayed meal must include the following details: the meal's title, an image of the meal, a list of ingredients with their corresponding measurements, and preparation instructions. Additionally, the 'result heading' (identified by data-testid='result-heading') and the 'meals container' (identified by data-testid='meals-container') must be cleared and remain empty. If the API request fails, the 'single meal container' must display an error message stating 'Failed to fetch a random meal.'"
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Automatically display a random meal on page load\n  The system must fetch and display a random meal in the single meal container when the page loads.\n\n\nScenario: [Normal] Display a random meal on page load\n    Given the user opens the \"Meal Finder\" webpage\n    When the page finishes loading\n    Then the \"single meal container\" with data-testid \"single-meal-container\" should display a meal\n    And the meal should include a title, an image, and a list of ingredients\n    And the \"result heading\" with data-testid \"result-heading\" should be empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the user opens the \"Meal Finder\" webpage')\ndef step_given_user_opens_meal_finder_webpage(context):\n    # Initialize the WebDriver\n    context.driver = webdriver.Chrome()\n    # Navigate to the test page\n    context.driver.get(f\"file://index.html\")\n    # Maximize the browser window\n    context.driver.maximize_window()\n    time.sleep(1)  # Allow the page to load completely\n\n@when('the page finishes loading')\ndef step_when_page_finishes_loading(context):\n    # Wait for the single meal container to be visible\n    WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    time.sleep(1)  # Ensure the page has fully loaded\n\n@then('the \"single meal container\" with data-testid \"single-meal-container\" should display a meal')\ndef step_then_single_meal_container_displays_meal(context):\n    # Locate the single meal container\n    single_meal_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='single-meal-container']\")\n    # Check if the container is visible\n    assert single_meal_container.is_displayed(), \"Single meal container is not visible\"\n    time.sleep(1)\n\n@then('the meal should include a title, an image, and a list of ingredients')\ndef step_then_meal_includes_title_image_ingredients(context):\n    # Locate the title, image, and ingredients within the single meal container\n    single_meal_container = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='single-meal-container']\")\n    title = single_meal_container.find_element(By.TAG_NAME, \"h1\")\n    image = single_meal_container.find_element(By.TAG_NAME, \"img\")\n    ingredients = single_meal_container.find_element(By.TAG_NAME, \"ul\")\n\n    # Validate the presence of title, image, and ingredients\n    assert title.is_displayed(), \"Meal title is not displayed\"\n    assert image.is_displayed(), \"Meal image is not displayed\"\n    assert ingredients.is_displayed(), \"Meal ingredients list is not displayed\"\n    time.sleep(1)\n\n@then('the \"result heading\" with data-testid \"result-heading\" should be empty')\ndef step_then_result_heading_should_be_empty(context):\n    # Locate the result heading\n    result_heading = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-heading']\")\n    # Validate that the result heading is empty\n    assert result_heading.text.strip() == \"\", f\"Result heading is not empty: {result_heading.text.strip()}\"\n    time.sleep(1)\n\n# Teardown step to close the browser after tests\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                }
            ]
        },
        "5": {
            "requirement": {
                "description": "When the user submits the search form with an empty input field or an input containing only whitespace, the system must fetch and display a random meal in the single meal container. The search form is identified by the data-testid 'submit-form', and the search input field is identified by the data-testid 'search-input'. The search button is identified by the data-testid 'search-button'. Upon submission, the single meal container, identified by the data-testid 'single-meal-container', should be updated to display the random meal details, including the meal name, image, category, area, ingredients, and instructions. The result heading, identified by the data-testid 'result-heading', should be cleared to ensure no search results are displayed."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: REQ-005 - Display Random Meal on Empty Search Submission\n  The system must fetch and display a random meal in the single meal container when the user submits the search form with an empty input field.\n\n\nScenario: [Normal] Submit search form with empty input field\n    Given the \"Meal Finder\" webpage is loaded\n    And the search input field with data-testid \"search-input\" is empty\n    When the user clicks the search button with data-testid \"search-button\"\n    Then the single meal container with data-testid \"single-meal-container\" should display a random meal\n    And the result heading with data-testid \"result-heading\" should be empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the \"Meal Finder\" webpage is loaded')\ndef step_given_meal_finder_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is empty')\ndef step_given_search_input_field_is_empty(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the single meal container with data-testid \"single-meal-container\" should display a random meal')\ndef step_then_single_meal_container_displays_random_meal(context):\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.text.strip() != \"\", \"Expected a random meal to be displayed, but the container is empty.\"\n    time.sleep(1)\n\n@then('the result heading with data-testid \"result-heading\" should be empty')\ndef step_then_result_heading_should_be_empty(context):\n    result_heading = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-heading']\"))\n    )\n    assert result_heading.text.strip() == \"\", f\"Expected result heading to be empty, but got '{result_heading.text}'.\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: REQ-005 - Display Random Meal on Empty Search Submission\n  The system must fetch and display a random meal in the single meal container when the user submits the search form with an empty input field.\n\n\nScenario: [Edge] Submit search form with whitespace in input field\n    Given the \"Meal Finder\" webpage is loaded\n    And the search input field with data-testid \"search-input\" contains only whitespace\n    When the user clicks the search button with data-testid \"search-button\"\n    Then the single meal container with data-testid \"single-meal-container\" should display a random meal\n    And the result heading with data-testid \"result-heading\" should be empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the \"Meal Finder\" webpage is loaded')\ndef step_given_meal_finder_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow page to load\n\n@given('the search input field with data-testid \"search-input\" contains only whitespace')\ndef step_given_search_input_contains_whitespace(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    search_input.send_keys(\"   \")  # Input whitespace\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)  # Allow time for search action\n\n@then('the single meal container with data-testid \"single-meal-container\" should display a random meal')\ndef step_then_single_meal_container_displays_random_meal(context):\n    single_meal_container = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='single-meal-container']\"))\n    )\n    assert single_meal_container.is_displayed(), \"Single meal container is not displayed\"\n    assert single_meal_container.text.strip() != \"\", \"Single meal container is empty\"\n    time.sleep(1)\n\n@then('the result heading with data-testid \"result-heading\" should be empty')\ndef step_then_result_heading_should_be_empty(context):\n    result_heading = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-heading']\"))\n    )\n    assert result_heading.text.strip() == \"\", f\"Result heading is not empty: {result_heading.text.strip()}\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "10": {
            "requirement": {
                "description": "The system must clear the search input field (identified by the attribute data-testid='search-input') after the user submits the search form (identified by the attribute data-testid='submit-form') under all scenarios. This includes: (1) a valid search where results are successfully fetched and displayed, (2) an empty search submission where no input is provided, and (3) an invalid search where no results are found. The clearing of the input field must occur immediately after the form submission event is triggered, regardless of the outcome of the search. The search button is identified by the attribute data-testid='search-button'."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Clear search input field after form submission\n  The system must clear the search input field after the user submits the search form to ensure a clean state for subsequent searches.\n\n\n  Scenario: [Normal] Clear search input field after a valid search\n    Given the user is on the \"Meal Finder\" page\n    And the search input field with data-testid \"search-input\" is visible\n    And the user enters \"chicken\" into the search input field with data-testid \"search-input\"\n    When the user clicks the search button with data-testid \"search-button\"\n    Then the search input field with data-testid \"search-input\" should be empty\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the \"Meal Finder\" page')\ndef step_given_user_on_meal_finder_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert is_visible(search_input), \"Search input field is not visible\"\n    time.sleep(1)\n\n@given('the user enters \"chicken\" into the search input field with data-testid \"search-input\"')\ndef step_given_user_enters_chicken(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.send_keys(\"chicken\")\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the search input field with data-testid \"search-input\" should be empty')\ndef step_then_search_input_should_be_empty(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute('value') == \"\", \"Search input field is not empty\"\n    time.sleep(1)\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Clear search input field after form submission\n  The system must clear the search input field after the user submits the search form to ensure a clean state for subsequent searches.\n\n\n  Scenario: [Edge] Clear search input field after submitting an empty search\n    Given the user is on the \"Meal Finder\" page\n    And the search input field with data-testid \"search-input\" is visible\n    And the search input field with data-testid \"search-input\" is empty\n    When the user clicks the search button with data-testid \"search-button\"\n    Then the search input field with data-testid \"search-input\" should remain empty\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\n# Placeholder for dynamic file path handling\nfile_path = \"index.html\"\n\n# Background setup for all scenarios\n@given('the user is on the \"Meal Finder\" page')\ndef step_user_on_meal_finder_page(context):\n    # Initialize the WebDriver and navigate to the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n\n@then('the browser is closed')\ndef step_close_browser(context):\n    # Close the browser driver\n    context.driver.quit()\n\n# Step implementations for the scenario\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_search_input_visible(context):\n    # Wait for the search input field to be visible\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert search_input.is_displayed(), \"Search input field is not visible\"\n\n@given('the search input field with data-testid \"search-input\" is empty')\ndef step_search_input_empty(context):\n    # Verify that the search input field is empty\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute(\"value\") == \"\", \"Search input field is not empty\"\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_user_clicks_search_button(context):\n    # Wait for the search button to be clickable and click it\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)  # Pause to allow the page to process the click\n\n@then('the search input field with data-testid \"search-input\" should remain empty')\ndef step_search_input_remains_empty(context):\n    # Verify that the search input field is still empty after submission\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute(\"value\") == \"\", \"Search input field is not empty after submission\""
                },
                {
                    "test_case": [
                        "Feature: Clear search input field after form submission\n  The system must clear the search input field after the user submits the search form to ensure a clean state for subsequent searches.\n\n\nScenario: [Error] Clear search input field after a failed search due to no results\n    Given the user is on the \"Meal Finder\" page\n    And the search input field with data-testid \"search-input\" is visible\n    And the user enters \"invalidsearchterm\" into the search input field with data-testid \"search-input\"\n    When the user clicks the search button with data-testid \"search-button\"\n    Then the search input field with data-testid \"search-input\" should be empty"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the user is on the \"Meal Finder\" page')\ndef step_user_on_meal_finder_page(context):\n    # Initialize the WebDriver and navigate to the test page\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    context.driver.maximize_window()\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_search_input_field_visible(context):\n    # Wait for the search input field to be visible\n    WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n\n@given('the user enters \"invalidsearchterm\" into the search input field with data-testid \"search-input\"')\ndef step_user_enters_search_term(context):\n    # Locate the search input field and enter the term\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    search_input.send_keys(\"invalidsearchterm\")\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_user_clicks_search_button(context):\n    # Locate the search button and click it\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the search input field with data-testid \"search-input\" should be empty')\ndef step_search_input_field_should_be_empty(context):\n    # Verify that the search input field is empty\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute(\"value\") == \"\", \"Search input field is not empty\"\n    time.sleep(1)\n\n# Teardown after all steps\ndef after_scenario(context, scenario):\n    if hasattr(context, 'driver'):\n        context.driver.quit()"
                }
            ]
        }
    }
}