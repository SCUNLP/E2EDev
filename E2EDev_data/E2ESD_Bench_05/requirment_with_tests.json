{
    "summary": {
        "overview": "The application is a web-based dictionary that allows users to search for word definitions, pronunciations, and examples. It also provides a daily quote, manages bookmarks for frequently accessed words, and maintains a history of recent searches.",
        "predefined_options": "The application uses predefined options such as default values for input fields and preset selections for bookmarks and recent searches.",
        "external_resources": "The application uses external resources such as quotes from 'https://type.fit/api/quotes' and 'http://api.quotable.io/random', and word data from 'https://api.dictionaryapi.dev/api/v2/entries/en/'.",
        "external_js_libraries": "The application uses external JavaScript libraries such as jQuery (https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js), Bootstrap (https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js), and Modernizr (https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.js)."
    },
    "finegrained_rewith_test": {
        "2": {
            "requirement": {
                "description": "The system must allow users to interact with the search functionality on the 'Dictionary' webpage. When the search input field, identified by data-testid 'search-input', is empty and the user clicks the 'Search' button (data-testid 'search-button'), a toast notification with data-testid 'error-toast' should be displayed, containing the message \"ERROR: Please type the word to be searched...\". If the search input contains a valid word, the error toast should not be shown, ensuring the user is only prompted when necessary."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Display error toast notification when search input is empty\n  The system should display a toast notification with an error message when the search button is clicked without entering a word in the search input field.\n\n\n  Scenario: [Normal] Display error toast when search input is empty\n    Given the \"Dictionary\" webpage is loaded\n    And the search input field with data-testid \"search-input\" is empty\n    When the user clicks the \"Search\" button with data-testid \"search-button\"\n    Then the error toast with data-testid \"error-toast\" should be visible\n    And the toast message should be \"ERROR: Please type the word to be searched...\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the \"Dictionary\" webpage is loaded')\ndef step_given_dictionary_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@given('the search input field with data-testid \"search-input\" is empty')\ndef step_given_search_input_field_is_empty(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    time.sleep(1)  # Allow time for the action to complete\n\n@when('the user clicks the \"Search\" button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)  # Allow time for the action to complete\n\n@then('the error toast with data-testid \"error-toast\" should be visible')\ndef step_then_error_toast_should_be_visible(context):\n    error_toast = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='error-toast']\"))\n    )\n    assert error_toast.is_displayed(), \"Error toast is not visible\"\n\n@then('the toast message should be \"ERROR: Please type the word to be searched...\"')\ndef step_then_toast_message_should_be_correct(context):\n    error_toast = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='error-toast']\")\n    toast_message = error_toast.find_element(By.CLASS_NAME, \"toast-body\").text\n    expected_message = \"ERROR: Please type the word to be searched...\"\n    assert expected_message in toast_message, f\"Expected '{expected_message}' but got '{toast_message}'\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Display error toast notification when search input is empty\n  The system should display a toast notification with an error message when the search button is clicked without entering a word in the search input field.\n\n\n  Scenario: [Error] No error toast when search input contains a valid word\n    Given the \"Dictionary\" webpage is loaded\n    And the search input field with data-testid \"search-input\" contains the word \"example\"\n    When the user clicks the \"Search\" button with data-testid \"search-button\"\n    Then the error toast with data-testid \"error-toast\" should not be visible"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the \"Dictionary\" webpage is loaded')\ndef step_given_dictionary_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow page to load\n\n@given('the search input field with data-testid \"search-input\" contains the word \"example\"')\ndef step_given_search_input_contains_word(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    search_input.send_keys(\"example\")\n    time.sleep(1)  # Allow input to be processed\n\n@when('the user clicks the \"Search\" button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)  # Allow action to be processed\n\n@then('the error toast with data-testid \"error-toast\" should not be visible')\ndef step_then_error_toast_should_not_be_visible(context):\n    error_toast = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='error-toast']\")\n    assert not error_toast.is_displayed(), \"Error toast is visible when it should not be.\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "3": {
            "requirement": {
                "description": "The web application must allow users to search for word details. When a user enters a word in the search input field (data-testid 'search-input') and clicks the 'Search' button (data-testid 'search-button'), the system should fetch the word's definition, pronunciation, and example from the dictionary API. A result card (data-testid 'result-card') should then be displayed with the searched word as the title (data-testid 'card-title'), its pronunciation (data-testid 'word-pronunciation'), meaning (data-testid 'word-meaning'), and an example sentence (data-testid 'word-example'). "
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Fetch and display word details upon clicking the 'Search' button\n  The system should fetch the word's definition, pronunciation, and example from the dictionary API and display them in the result card when a valid word is entered and the 'Search' button is clicked.\n\n\nScenario: [Normal] Display word details for a valid word\n    Given the user is on the Dictionary page\n    And the search input field with data-testid 'search-input' is visible\n    When the user enters 'example' into the search input field with data-testid 'search-input'\n    And the user clicks the 'Search' button with data-testid 'search-button'\n    Then the result card with data-testid 'result-card' should be visible\n    And the card title with data-testid 'card-title' should display 'example'\n    And the word pronunciation with data-testid 'word-pronunciation' should display the pronunciation text\n    And the word meaning with data-testid 'word-meaning' should display the definition\n    And the word example with data-testid 'word-example' should display an example sentence"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \\'search-input\\' is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert is_visible(search_input), \"Search input field is not visible\"\n\n@when('the user enters \\'example\\' into the search input field with data-testid \\'search-input\\'')\ndef step_when_user_enters_example(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    search_input.send_keys(\"example\")\n    time.sleep(1)\n\n@when('the user clicks the \\'Search\\' button with data-testid \\'search-button\\'')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the result card with data-testid \\'result-card\\' should be visible')\ndef step_then_result_card_visible(context):\n    result_card = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n    )\n    assert is_visible(result_card), \"Result card is not visible\"\n\n@then('the card title with data-testid \\'card-title\\' should display \\'example\\'')\ndef step_then_card_title_displays_example(context):\n    card_title = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='card-title']\")\n    expected_text = \"example\"\n    assert expected_text.lower() in card_title.text.lower(), f\"Expected '{expected_text}' in '{card_title.text}'\"\n\n@then('the word pronunciation with data-testid \\'word-pronunciation\\' should display the pronunciation text')\ndef step_then_word_pronunciation_displays(context):\n    word_pronunciation = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-pronunciation']\")\n    assert word_pronunciation.text.strip(), \"Word pronunciation text is not displayed\"\n\n@then('the word meaning with data-testid \\'word-meaning\\' should display the definition')\ndef step_then_word_meaning_displays(context):\n    word_meaning = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-meaning']\")\n    assert word_meaning.text.strip(), \"Word meaning text is not displayed\"\n\n@then('the word example with data-testid \\'word-example\\' should display an example sentence')\ndef step_then_word_example_displays(context):\n    word_example = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-example']\")\n    assert word_example.text.strip(), \"Word example text is not displayed\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Fetch and display word details upon clicking the 'Search' button\n  The system should fetch the word's definition, pronunciation, and example from the dictionary API and display them in the result card when a valid word is entered and the 'Search' button is clicked.\n\n\nScenario: [Edge] Display word details for a word with multiple meanings\n    Given the user is on the Dictionary page\n    And the search input field with data-testid 'search-input' is visible\n    When the user enters 'set' into the search input field with data-testid 'search-input'\n    And the user clicks the 'Search' button with data-testid 'search-button'\n    Then the result card with data-testid 'result-card' should be visible\n    And the card title with data-testid 'card-title' should display 'set'\n    And the word pronunciation with data-testid 'word-pronunciation' should display the pronunciation text\n    And the word meaning with data-testid 'word-meaning' should display one of the definitions\n    And the word example with data-testid 'word-example' should display an example sentence"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \\'search-input\\' is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert is_visible(search_input), \"Search input field is not visible\"\n\n@when('the user enters \\'set\\' into the search input field with data-testid \\'search-input\\'')\ndef step_when_user_enters_set(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    search_input.send_keys(\"set\")\n    time.sleep(1)\n\n@when('the user clicks the \\'Search\\' button with data-testid \\'search-button\\'')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the result card with data-testid \\'result-card\\' should be visible')\ndef step_then_result_card_visible(context):\n    result_card = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n    )\n    assert is_visible(result_card), \"Result card is not visible\"\n\n@then('the card title with data-testid \\'card-title\\' should display \\'set\\'')\ndef step_then_card_title_display_set(context):\n    card_title = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='card-title']\")\n    assert \"set\" in card_title.text.lower(), f\"Expected 'set' in '{card_title.text}'\"\n\n@then('the word pronunciation with data-testid \\'word-pronunciation\\' should display the pronunciation text')\ndef step_then_word_pronunciation_display(context):\n    word_pronunciation = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-pronunciation']\")\n    assert word_pronunciation.text.strip() != \"\", \"Pronunciation text is empty\"\n\n@then('the word meaning with data-testid \\'word-meaning\\' should display one of the definitions')\ndef step_then_word_meaning_display(context):\n    word_meaning = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-meaning']\")\n    assert word_meaning.text.strip() != \"\", \"Word meaning text is empty\"\n\n@then('the word example with data-testid \\'word-example\\' should display an example sentence')\ndef step_then_word_example_display(context):\n    word_example = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='word-example']\")\n    assert word_example.text.strip() != \"\", \"Word example text is empty\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Fetch and display word details upon clicking the 'Search' button\n  The system should fetch the word's definition, pronunciation, and example from the dictionary API and display them in the result card when a valid word is entered and the 'Search' button is clicked.\n\n\n  Scenario: [Error] Attempt to search with an empty input\n    Given the user is on the Dictionary page\n    And the search input field with data-testid \"search-input\" is visible\n    When the user leaves the search input field with data-testid \"search-input\" empty\n    And the user clicks the \"Search\" button with data-testid \"search-button\"\n    Then the result card with data-testid \"result-card\" should not be visible\n    And the error toast with data-testid \"error-toast\" should be displayed\n    And the error toast should display the message \"ERROR: Please type the word to be searched...\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" is visible')\ndef step_given_search_input_visible(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert is_visible(search_input), \"Search input field is not visible\"\n    time.sleep(1)\n\n@when('the user leaves the search input field with data-testid \"search-input\" empty')\ndef step_when_search_input_empty(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    search_input.clear()\n    time.sleep(1)\n\n@when('the user clicks the \"Search\" button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the result card with data-testid \"result-card\" should not be visible')\ndef step_then_result_card_not_visible(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-card']\")\n    assert not is_visible(result_card), \"Result card is visible\"\n    time.sleep(1)\n\n@then('the error toast with data-testid \"error-toast\" should be displayed')\ndef step_then_error_toast_displayed(context):\n    error_toast = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='error-toast']\"))\n    )\n    assert is_visible(error_toast), \"Error toast is not displayed\"\n    time.sleep(1)\n\n@then('the error toast should display the message \"ERROR: Please type the word to be searched...\"')\ndef step_then_error_toast_message(context):\n    error_toast = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='error-toast']\")\n    expected_message = \"ERROR: Please type the word to be searched...\"\n    assert expected_message.lower() in error_toast.text.lower(), f\"Expected '{expected_message}' in '{error_toast.text}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "4": {
            "requirement": {
                "description": "The system must provide a 'Reset' button on the Dictionary page that clears the search input field and hides the result card. When the user clicks the 'Reset' button (data-testid 'reset-button'), the search input field (data-testid 'search-input') should be cleared, and the result card (data-testid 'result-card') should be hidden. This functionality should work whether the search input field is empty or contains text, and regardless of whether a search has been performed. The system should ensure that the result card remains hidden after the reset, providing a consistent user experience."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Reset Search Functionality\n  The system should clear the search input field and hide the result card when the 'Reset' button is clicked.\n\n\nScenario: [Normal] Reset button clears the search input and hides the result card\n    Given the user is on the Dictionary page\n    And the search input field with data-testid \"search-input\" contains the text \"example\" \n    And the user clicks the search button with data-testid \"search-button\"\n    And the result card with data-testid \"result-card\" is visible\n    When the user clicks the 'Reset' button with data-testid \"reset-button\"\n    Then the search input field with data-testid \"search-input\" should be empty\n    And the result card with data-testid \"result-card\" should not be visible"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nimport time\n\n@given('the user is on the Dictionary page')\ndef step_impl(context):\n    file_path = \"index.html\"\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n\n@given('the search input field with data-testid \"search-input\" contains the text \"example\"')\ndef step_impl(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"search-input\"]')\n    search_input.clear()\n    search_input.send_keys(\"example\")\n\n@given('the user clicks the search button with data-testid \"search-button\"')\ndef step_impl(context):\n    search_button = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"search-button\"]')\n    search_button.click()\n    time.sleep(2)  # Wait for search results to load\n\n@given('the result card with data-testid \"result-card\" is visible')\ndef step_impl(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"result-card\"]')\n    assert result_card.is_displayed()\n\n@when('the user clicks the \\'Reset\\' button with data-testid \"reset-button\"')\ndef step_impl(context):\n    reset_button = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"reset-button\"]')\n    reset_button.click()\n    time.sleep(1)  # Wait for reset action to complete\n\n@then('the search input field with data-testid \"search-input\" should be empty')\ndef step_impl(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"search-input\"]')\n    assert search_input.get_attribute('value') == \"\"\n\n@then('the result card with data-testid \"result-card\" should not be visible')\ndef step_impl(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, '[data-testid=\"result-card\"]')\n    assert not result_card.is_displayed()\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Reset Search Functionality\n  The system should clear the search input field and hide the result card when the 'Reset' button is clicked.\n\n\nScenario: [Edge] Reset button is clicked when the search input is already empty\n    Given the user is on the Dictionary page\n    And the search input field with data-testid \"search-input\" contains the text \"example\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the result card with data-testid \"result-card\" is visible\n    And the user clears the search input field with data-testid \"search-input\"\n    When the user clicks the 'Reset' button with data-testid \"reset-button\"\n    Then the search input field with data-testid \"search-input\" should remain empty\n    And the result card with data-testid \"result-card\" should not be visible"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the search input field with data-testid \"search-input\" contains the text \"example\"')\ndef step_given_search_input_contains_text(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.send_keys(\"example\")\n    time.sleep(1)\n\n@given('the user clicks the search button with data-testid \"search-button\"')\ndef step_given_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@given('the result card with data-testid \"result-card\" is visible')\ndef step_given_result_card_is_visible(context):\n    result_card = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n    )\n    assert result_card.is_displayed(), \"Result card should be visible\"\n    time.sleep(1)\n\n@given('the user clears the search input field with data-testid \"search-input\"')\ndef step_given_user_clears_search_input(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    time.sleep(1)\n\n@when('the user clicks the \\'Reset\\' button with data-testid \"reset-button\"')\ndef step_when_user_clicks_reset_button(context):\n    reset_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='reset-button']\"))\n    )\n    reset_button.click()\n    time.sleep(1)\n\n@then('the search input field with data-testid \"search-input\" should remain empty')\ndef step_then_search_input_should_remain_empty(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    assert search_input.get_attribute('value') == \"\", \"Search input should be empty\"\n    time.sleep(1)\n\n@then('the result card with data-testid \"result-card\" should not be visible')\ndef step_then_result_card_should_not_be_visible(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-card']\")\n    assert not result_card.is_displayed(), \"Result card should not be visible\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Reset Search Functionality\n  The system should clear the search input field and hide the result card when the 'Reset' button is clicked.\n\n\n  Scenario: [Error] Reset button is clicked when no search has been performed\n    Given the user is on the Dictionary page\n    And the search input field with data-testid \"search-input\" is empty\n    And the result card with data-testid \"result-card\" is not visible\n    When the user clicks the 'Reset' button with data-testid \"reset-button\"\n    Then the search input field with data-testid \"search-input\" should remain empty\n    And the result card with data-testid \"result-card\" should remain not visible"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@given('the search input field with data-testid \"search-input\" is empty')\ndef step_given_search_input_is_empty(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute('value') == \"\", \"Search input is not empty\"\n\n@given('the result card with data-testid \"result-card\" is not visible')\ndef step_given_result_card_not_visible(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-card']\")\n    assert not result_card.is_displayed(), \"Result card is visible\"\n\n@when('the user clicks the \\'Reset\\' button with data-testid \"reset-button\"')\ndef step_when_user_clicks_reset_button(context):\n    reset_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='reset-button']\"))\n    )\n    reset_button.click()\n    time.sleep(1)  # Allow time for the reset action to take effect\n\n@then('the search input field with data-testid \"search-input\" should remain empty')\ndef step_then_search_input_remains_empty(context):\n    search_input = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-input']\")\n    assert search_input.get_attribute('value') == \"\", \"Search input is not empty after reset\"\n\n@then('the result card with data-testid \"result-card\" should remain not visible')\ndef step_then_result_card_remains_not_visible(context):\n    result_card = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='result-card']\")\n    assert not result_card.is_displayed(), \"Result card is visible after reset\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "5": {
            "requirement": {
                "description": "The web application must allow users to toggle the bookmark status of a word's result card and update the list of bookmarked words in the offcanvas section. When the user clicks the 'Bookmark' icon (data-testid 'bookmark-icon') on a word's result card (data-testid 'result-card'), the system should update the icon to reflect the current bookmark status. If the word is bookmarked, it should be added to the list of bookmarked words displayed in the offcanvas section (data-testid 'bookmarked-words-list'). The user can view this list by clicking the 'Bookmarks' button (data-testid 'bookmark-button'), which opens the offcanvas section. The system must ensure that the list accurately reflects the bookmarked words, allowing users to add and remove words from the bookmark list by toggling the bookmark icon."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Toggle Bookmark Status and Update Bookmarked Words List\n  The system should allow users to toggle the bookmark status of a word's result card and update the list of bookmarked words in the offcanvas section.\n\n\nScenario: [Normal] Bookmark a word and update the list\n    Given the webpage is loaded\n    And the user has searched for a word and the result card is displayed with data-testid \"result-card\"\n    When the user clicks the bookmark icon with data-testid \"bookmark-icon\"\n    Then the user clicks the bookmark word list show button with data-testid \"bookmark-button\" to show the bookmarked words\n    And the word should be added to the list of bookmarked words in the offcanvas section with data-testid \"bookmarked-words-list\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_expanded(element):\n    aria = element.get_attribute(\"aria-expanded\")\n    if aria is not None:\n        return aria == \"true\"\n    class_list = element.get_attribute(\"class\").split()\n    if any(cls in class_list for cls in [\"expanded\", \"open\", \"show\"]):\n        return True\n    data_expanded = element.get_attribute(\"data-expanded\")\n    if data_expanded is not None:\n        return data_expanded == \"true\"\n    return element.is_displayed()\n\n@given('the webpage is loaded')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the user has searched for a word and the result card is displayed with data-testid \"result-card\"')\ndef step_given_result_card_displayed(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.send_keys(\"example\")\n    search_button = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='search-button']\")\n    search_button.click()\n    time.sleep(1)\n    result_card = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n    )\n    assert result_card.is_displayed(), \"Result card is not displayed\"\n\n@when('the user clicks the bookmark icon with data-testid \"bookmark-icon\"')\ndef step_when_click_bookmark_icon(context):\n    bookmark_icon = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-icon']\"))\n    )\n    bookmark_icon.click()\n    time.sleep(1)\n    # Verify the bookmark icon changes state to indicate the word is bookmarked\n    icon_class = bookmark_icon.find_element(By.TAG_NAME, \"i\").get_attribute(\"class\")\n    assert \"bi-bookmark-check-fill\" in icon_class, \"Bookmark icon did not change state\"\n\n@then('the user clicks the bookmark word list show button with data-testid \"bookmark-button\" to show the bookmarked words')\ndef step_then_click_bookmark_button(context):\n    bookmark_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-button']\"))\n    )\n    bookmark_button.click()\n    time.sleep(1)\n\n@then('the word should be added to the list of bookmarked words in the offcanvas section with data-testid \"bookmarked-words-list\"')\ndef step_then_verify_bookmarked_words_list(context):\n    bookmarked_words_list = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\"))\n    )\n    # Extract all bookmarked words from the list\n    bookmarked_words_items = bookmarked_words_list.find_elements(By.TAG_NAME, \"li\")\n    bookmarked_words = [word.text.lower() for word in bookmarked_words_items]\n\n    assert \"example\".lower() in bookmarked_words, \"The word 'example' is not in the bookmarked words list\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "8": {
            "requirement": {
                "description": "The system should maintain a list of the five most recent searched words and display them in the 'Recent Searches' section (data-testid 'recently-searched'). Each time the user performs a search by entering a word in the search input field (data-testid 'search-input') and clicking the 'Search' button (data-testid 'search-button'), the system should update the list. If the list exceeds five entries, the oldest search should be removed to make room for the new one. "
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Maintain and Display Recently Searched Words\n  The system should maintain a list of recently searched words and display them in the 'Recent Searches' section.\n\n\n  Scenario: [Normal] Add a word to the recently searched list\n    Given the user is on the Dictionary page\n    When the user enters \"example\" into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    Then the \"Recent Searches\" section with data-testid \"recently-searched\" should display the word \"example\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow page to load\n\n@when('the user enters \"example\" into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_example(context):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    search_input.send_keys(\"example\")\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the \"Recent Searches\" section with data-testid \"recently-searched\" should display the word \"example\"')\ndef step_then_recent_searches_display_example(context):\n    recently_searched = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='recently-searched']\"))\n    )\n    assert \"example\" in recently_searched.text, f\"Expected 'example' in recent searches, but got '{recently_searched.text}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Maintain and Display Recently Searched Words\n  The system should maintain a list of recently searched words and display them in the 'Recent Searches' section.\n\n\n  Scenario: [Edge] Add multiple words to the recently searched list\n    Given the user is on the Dictionary page\n    When the user enters \"example\" into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters \"test\" into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    Then the \"Recent Searches\" section with data-testid \"recently-searched\" should display the words \"example\" and \"test\"\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when('the user enters \"{word}\" into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_word(context, word):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    search_input.send_keys(word)\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the \"Recent Searches\" section with data-testid \"recently-searched\" should display the words \"example\" and \"test\"')\ndef step_then_recent_searches_display_words(context):\n    recently_searched = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='recently-searched']\"))\n    )\n    recent_words = recently_searched.text.lower()\n    assert \"example\" in recent_words, f\"Expected 'example' in recent searches, but got '{recent_words}'\"\n    assert \"test\" in recent_words, f\"Expected 'test' in recent searches, but got '{recent_words}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Maintain and Display Recently Searched Words\n  The system should maintain a list of recently searched words and display them in the 'Recent Searches' section.\n\n\nScenario: [Edge] Display a maximum of five recently searched words\n    Given the user is on the Dictionary page\n    When the user enters \"sunset\" into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters \"whisper” into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters “jigsaw” into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters \"word\" into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters “sparkle” into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    And the user enters “meadow” into the search input with data-testid \"search-input\"\n    And the user clicks the search button with data-testid \"search-button\"\n    Then the \"Recent Searches\" section with data-testid \"recently-searched\" should display the words \"whisper\", “jigsaw\", \"word\", \"sparkle\", and \"meadow\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when('the user enters \"{word}\" into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_word(context, word):\n    search_input = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n    )\n    search_input.clear()\n    search_input.send_keys(word)\n    time.sleep(1)\n\n@when('the user enters \"whisper” into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_whisper(context):\n    step_when_user_enters_word(context, \"whisper\")\n\n@when('the user enters “jigsaw” into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_jigsaw(context):\n    step_when_user_enters_word(context, \"jigsaw\")\n\n@when('the user enters “sparkle” into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_sparkle(context):\n    step_when_user_enters_word(context, \"sparkle\")\n\n@when('the user enters “meadow” into the search input with data-testid \"search-input\"')\ndef step_when_user_enters_meadow(context):\n    step_when_user_enters_word(context, \"meadow\")\n\n@when('the user clicks the search button with data-testid \"search-button\"')\ndef step_when_user_clicks_search_button(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the \"Recent Searches\" section with data-testid \"recently-searched\" should display the words \"whisper\", “jigsaw\", \"word\", \"sparkle\", and \"meadow\"')\ndef step_then_recent_searches_display_words(context):\n    recent_searches = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='recently-searched']\"))\n    )\n    recent_words = recent_searches.text.lower()\n    expected_words = [\"whisper\", \"jigsaw\", \"word\", \"sparkle\", \"meadow\"]\n    for word in expected_words:\n        assert word in recent_words, f\"Expected '{word}' in recent searches, but got '{recent_words}'\"\n    time.sleep(1)\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Maintain and Display Recently Searched Words\n  The system should maintain a list of recently searched words and display them in the 'Recent Searches' section.\n\n\n  Scenario: [Error] Attempt to add an empty search to the recently searched list\n    Given the user is on the Dictionary page\n    When the user clicks the search button with data-testid \"search-button\" without entering a word\n    Then the \"Recent Searches\" section with data-testid \"recently-searched\" should not display any new entries\n    And an error toast with data-testid \"error-toast\" should be visible with the message \"ERROR: Please type the word to be searched...\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the Dictionary page')\ndef step_given_user_on_dictionary_page(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@when('the user clicks the search button with data-testid \"search-button\" without entering a word')\ndef step_when_user_clicks_search_button_without_word(context):\n    search_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n    )\n    search_button.click()\n    time.sleep(1)\n\n@then('the \"Recent Searches\" section with data-testid \"recently-searched\" should not display any new entries')\ndef step_then_recent_searches_should_not_display_new_entries(context):\n    recently_searched_section = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='recently-searched']\")\n    assert not recently_searched_section.text.strip(), \"Recent Searches section should be empty\"\n\n@then('an error toast with data-testid \"error-toast\" should be visible with the message \"ERROR: Please type the word to be searched...\"')\ndef step_then_error_toast_should_be_visible(context):\n    error_toast = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='error-toast']\"))\n    )\n    assert is_visible(error_toast), \"Error toast should be visible\"\n    expected_message = \"ERROR: Please type the word to be searched...\"\n    assert expected_message in error_toast.text, f\"Expected message '{expected_message}' in '{error_toast.text}'\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "9": {
            "requirement": {
                "description": "The web application must display a 'Back to Top' button (data-testid 'back-to-top-button') when the user scrolls more than 20 pixels down. Clicking the button should smoothly scroll the page to the top, and the button should hide once the page is at the top."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Back to Top Button Functionality\n  The system should scroll the page to the top when the 'Back to Top' button is clicked.\n\n\n  Scenario: [Normal] Clicking the 'Back to Top' button scrolls the page to the top\n    Given the user is on the \"Dictionary\" webpage\n    And the window height is low enough to display the \"Back to Top\" button\n    And the user has scrolled down the page\n    When the user clicks the 'Back to Top' button with data-testid 'back-to-top-button'\n    Then the page should scroll to the top\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_visible(element):\n    return element.is_displayed()\n\n@given('the user is on the \"Dictionary\" webpage')\ndef step_given_user_on_dictionary_webpage(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@given('the window height is low enough to display the \"Back to Top\" button')\ndef step_given_window_height_low(context):\n    context.driver.set_window_size(800, 600)\n\n@given('the user has scrolled down the page')\ndef step_given_user_scrolled_down(context):\n    context.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n    time.sleep(1)  # Allow time for the scroll action\n\n\n@when('the user clicks the \\'Back to Top\\' button with data-testid \\'back-to-top-button\\'')\ndef step_when_user_clicks_back_to_top_button(context):\n    back_to_top_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='back-to-top-button']\"))\n    )\n    back_to_top_button.click()\n    time.sleep(1)  # Allow time for the scroll action\n\n@then('the page should scroll to the top')\ndef step_then_page_should_scroll_to_top(context):\n    scroll_position = context.driver.execute_script(\"return window.pageYOffset;\")\n    assert scroll_position == 0, f\"Expected scroll position to be 0, but got {scroll_position}\"\n\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        },
        "10": {
            "requirement": {
                "description": "The system must allow users to manage bookmarked words in the offcanvas section. When the user clicks the 'Bookmarks' button (data-testid=\"bookmark-button\"), the offcanvas opens, displaying the bookmarked words list (data-testid=\"bookmarked-words-list\"). Each word has a close button (data-testid=\"bookmark-delete-button-${index}\") for removal. Clicking the close button deletes the word and updates the list. If no words are bookmarked, an <h5> with the text 'No words bookmarked !!' is shown in the offcanvas."
            },
            "test_cases": [
                {
                    "test_case": [
                        "Feature: Deleting Bookmarked Words\n  The system should allow users to delete bookmarked words from the list in the offcanvas section.\n\n\n  Scenario: [Normal] User deletes a bookmarked word successfully\n    Given the webpage is loaded\n    And the user has bookmarked words \"example\", \"test\", \"sample\"\n    When the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"\n    And the offcanvas section with data-testid \"bookmarked-words-list\" is displayed\n    And the user clicks the close button next to a bookmarked word with data-testid \"bookmark-delete-button-0\"\n    Then the bookmarked word is removed from the list\n    And the list updates to reflect the deletion\n"
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\ndef is_collapsed(element):\n    aria = element.get_attribute(\"aria-expanded\")\n    if aria is not None and aria.lower() == \"false\":\n        return True\n\n    class_attr = element.get_attribute(\"class\") or \"\"\n    class_list = class_attr.split()\n    if \"collapsed\" in class_list:\n        return True\n\n    data_expanded = element.get_attribute(\"data-expanded\")\n    if data_expanded is not None and data_expanded.lower() == \"false\":\n        return True\n\n    style = element.get_attribute(\"style\") or \"\"\n    if \"display: none\" in style or \"visibility: hidden\" in style or \"height: 0\" in style:\n        return True\n\n    return not element.is_displayed()\n\n@given('the webpage is loaded')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)\n\n@given('the user has bookmarked words \"example\", \"test\", \"sample\"')\ndef step_given_bookmarked_words_displayed(context):\n    # Ensure the offcanvas section is initially collapsed\n    words_to_bookmark = [\"example\", \"test\", \"sample\"]\n\n    for word in words_to_bookmark:\n        # Enter the word in the search input\n        search_input = WebDriverWait(context.driver, 10).until(\n            EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n        )\n        search_input.clear()\n        search_input.send_keys(word)\n\n        # Click the search button\n        search_button = WebDriverWait(context.driver, 10).until(\n            EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n        )\n        search_button.click()\n\n        # Wait for the result card to appear\n        WebDriverWait(context.driver, 10).until(\n            EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n        )\n\n        # Click the bookmark icon\n        bookmark_icon = WebDriverWait(context.driver, 10).until(\n            EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-icon']\"))\n        )\n        bookmark_icon.click()\n\n        time.sleep(1)  # Allow time for the bookmark action to complete\n\n\n@when('the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"')\ndef step_when_clicks_bookmarks_button(context):\n    bookmark_button = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmark-button']\")\n    bookmark_button.click()\n    time.sleep(1)\n\n@when('the offcanvas section with data-testid \"bookmarked-words-list\" is displayed')\ndef step_when_offcanvas_displayed(context):\n    offcanvas = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\")\n    WebDriverWait(context.driver, 10).until(EC.visibility_of(offcanvas))\n    assert not is_collapsed(offcanvas), \"Offcanvas section should be displayed\"\n\n@when('the user clicks the close button next to a bookmarked word with data-testid \"bookmark-delete-button-0\"')\ndef step_when_clicks_close_button(context):\n    close_button = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmark-delete-button-0']\")\n    close_button.click()\n    time.sleep(1)\n\n@then('the bookmarked word is removed from the list')\ndef step_then_bookmarked_word_removed(context):\n    bookmarked_words_list = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\")\n    assert len(bookmarked_words_list.find_elements(By.TAG_NAME, \"li\")) == 2, \"Bookmarked word was not removed\"\n\n@then('the list updates to reflect the deletion')\ndef step_then_list_updates(context):\n    # Verify the list is updated\n    bookmarked_words_list = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\")\n    assert len(bookmarked_words_list.find_elements(By.TAG_NAME, \"li\")) == 2, \"List did not update to reflect deletion\"\n\n    # Close the driver\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Deleting Bookmarked Words\n  The system should allow users to delete bookmarked words from the list in the offcanvas section.\n\n\nScenario: [Edge] User deletes the last bookmarked word\n    Given the webpage is loaded\n    And the user has bookmarked words \"example\"\n    When the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"\n    And the offcanvas section with data-testid \"bookmarked-words-list\" is displayed\n    And the user clicks the close button next to the last bookmarked word with data-testid \"bookmark-delete-button-0\"\n    Then the last bookmarked word is removed from the list\n    And the list displays a message \"No words bookmarked !!\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the webpage is loaded')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@given('the user has bookmarked words \"example\"')\ndef step_given_user_has_bookmarked_words(context):\n    # Assuming the bookmark functionality is already tested and the word \"example\" is bookmarked\n    # This step is a setup step and doesn't require Selenium interaction\n    words_to_bookmark = [\"example\"]\n\n    for word in words_to_bookmark:\n        # Enter the word in the search input\n        search_input = WebDriverWait(context.driver, 10).until(\n            EC.presence_of_element_located((By.CSS_SELECTOR, \"[data-testid='search-input']\"))\n        )\n        search_input.clear()\n        search_input.send_keys(word)\n\n        # Click the search button\n        search_button = WebDriverWait(context.driver, 10).until(\n            EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='search-button']\"))\n        )\n        search_button.click()\n\n        # Wait for the result card to appear\n        WebDriverWait(context.driver, 10).until(\n            EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='result-card']\"))\n        )\n\n        # Click the bookmark icon\n        bookmark_icon = WebDriverWait(context.driver, 10).until(\n            EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-icon']\"))\n        )\n        bookmark_icon.click()\n\n        time.sleep(1)\n\n@when('the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"')\ndef step_when_user_clicks_bookmarks_button(context):\n    bookmark_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-button']\"))\n    )\n    bookmark_button.click()\n    time.sleep(1)  # Allow time for the offcanvas to open\n\n@when('the offcanvas section with data-testid \"bookmarked-words-list\" is displayed')\ndef step_when_offcanvas_section_displayed(context):\n    offcanvas_section = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\"))\n    )\n    assert offcanvas_section.is_displayed(), \"Offcanvas section is not displayed\"\n\n@when('the user clicks the close button next to the last bookmarked word with data-testid \"bookmark-delete-button-0\"')\ndef step_when_user_clicks_delete_button(context):\n    delete_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-delete-button-0']\"))\n    )\n    delete_button.click()\n    time.sleep(1)  # Allow time for the word to be removed\n\n@then('the last bookmarked word is removed from the list')\ndef step_then_word_removed_from_list(context):\n    bookmarked_words_list = context.driver.find_element(By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\")\n    words = bookmarked_words_list.find_elements(By.TAG_NAME, \"li\")\n    assert len(words) == 0, \"Bookmarked word was not removed\"\n\n@then('the list displays a message \"No words bookmarked !!\"')\ndef step_then_list_displays_message(context):\n    message_element = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.XPATH, \"//h5[text()='No words bookmarked !!']\"))\n    )\n    assert message_element.is_displayed(), \"Message 'No words bookmarked !!' is not displayed\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                },
                {
                    "test_case": [
                        "Feature: Deleting Bookmarked Words\n  The system should allow users to delete bookmarked words from the list in the offcanvas section.\n\n\nScenario: [Error] User attempts to delete a bookmarked word when none are present\n    Given the webpage is loaded\n    When the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"\n    And the offcanvas section with data-testid \"bookmarked-words-list\" is displayed\n    Then the user sees the message \"No words bookmarked !!\""
                    ],
                    "step_code": "from behave import given, when, then\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\nfile_path = \"index.html\"\n\n@given('the webpage is loaded')\ndef step_given_webpage_loaded(context):\n    context.driver = webdriver.Chrome()\n    context.driver.get(f\"file://index.html\")\n    time.sleep(1)  # Allow time for the page to load\n\n@when('the user clicks the \"Bookmarks\" button with data-testid \"bookmark-button\"')\ndef step_when_user_clicks_bookmarks_button(context):\n    bookmark_button = WebDriverWait(context.driver, 10).until(\n        EC.element_to_be_clickable((By.CSS_SELECTOR, \"[data-testid='bookmark-button']\"))\n    )\n    bookmark_button.click()\n    time.sleep(1)  # Allow time for the offcanvas to appear\n\n@when('the offcanvas section with data-testid \"bookmarked-words-list\" is displayed')\ndef step_when_offcanvas_section_displayed(context):\n    offcanvas_section = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.CSS_SELECTOR, \"[data-testid='bookmarked-words-list']\"))\n    )\n    assert offcanvas_section.is_displayed(), \"Offcanvas section is not displayed\"\n    time.sleep(1)  # Allow time for the section to be fully visible\n\n@then('the user sees the message \"No words bookmarked !!\"')\ndef step_then_user_sees_no_words_bookmarked_message(context):\n    message_element = WebDriverWait(context.driver, 10).until(\n        EC.visibility_of_element_located((By.XPATH, \"//h5[text()='No words bookmarked !!']\"))\n    )\n    assert message_element.is_displayed(), \"Message 'No words bookmarked !!' is not displayed\"\n\ndef after_scenario(context, scenario):\n    context.driver.quit()"
                }
            ]
        }
    }
}